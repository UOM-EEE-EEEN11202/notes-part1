%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,british]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{notes\sphinxhyphen{}part1}
\date{Apr 14, 2025}
\release{0.1}
\author{Alex Casson}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
In this Part we’re going to look at a number of different ways in which computers operate. It would probably be possible to do an entire course on any one of these topics! Our aim isn’t to be the expert in all of them. Rather, the aim is to have enough familiarity in order to be able to progress with our programming.

\sphinxAtStartPar
We won’t get very far with our programming without needing to know a little about how computers work \sphinxstyleemphasis{under the hood} in order to know why our code looks the way it does. If we treat the computer as black box, it’s very hard to get the most oyt of it. We don’t need to know everything about what’s inside the box, but knowing a little helps a lot.

\sphinxAtStartPar
Remember that computers are human designed objects \sphinxhyphen{} they work the way they do because someone decided to make them work that way. Sometimes these decisions make a lot of sense. Sometimes the decision made sense at the time, possibly 50+ year ago. We might do it differently if we were to do it today, but we have to stick with what’s already in place. Sometimes, different people decided different things, and there are different standards or ways of doing things. We need to pick one to actually use, even if other choices are perfectly good and someone else might pick a different one. Before starting our programming we need to know a little about which choices we’re making and why. This includes learning about some common software development techniques.

\sphinxAtStartPar
In places some of what we cover will be a bit \sphinxstyleemphasis{approximate}. The descriptions are sufficient and accurate for the depth we need them to be for this course. If you go on to cover some of the topics in more detail, you might find that some of the definitions get refined and a bit tighter compared to what we have here.

\sphinxAtStartPar
The contents of Part 1 of the notes are:

\sphinxstepscope


\chapter{Motivation}
\label{\detokenize{chapters/motivation:motivation}}\label{\detokenize{chapters/motivation::doc}}
\sphinxAtStartPar
We’ll start off by giving some brief motivation on why programming is an important skill to learn. Programming and software development is a very large area, and so we also give some motivation for why we’ve selected the topics that we’re going to cover. This also gives some background and wider/general information to set the context for the rest of the course.

\sphinxstepscope


\section{Why study programming}
\label{\detokenize{chapters/motivation/why_programming:why-study-programming}}\label{\detokenize{chapters/motivation/why_programming::doc}}
\sphinxAtStartPar
Programming is the process of writing instructions for a computer to follow. Every time we use a computer system, whether that be a phone, a desktop/laptop, a super\sphinxhyphen{}computer, or an embedded system like wireless car keys, we interact with software that has been written by programming. Programming is a core skill to learn in order to automate common tasks and is widely used (possibly behind\sphinxhyphen{}the\sphinxhyphen{}scenes) in everyday tasks.

\sphinxAtStartPar
In an engineering context, programming is widely used for modelling and simulation. That is, making an approximation of something on a computer so that we can try out different options, or see what happens in different situations, without having to actually build the physical thing (which typically takes more time and more money than just simulating it). Programming is also widely used for analyzing large datasets, which would be impractical to do by hand. This could range from just calculating the mean, to programming advanced machine learning analyses.

\sphinxAtStartPar
Programming is thus a very important skill to develop. This applies equally whether you go on to focus on software development, whether you focus on other aspects in engineering but need to analyze datasets coming from experiments, or whether you go on to focus on general office work where repetitive tasks could be automated. You’ll use programming skills in a wide number of courses at the University of Manchester.

\sphinxstepscope


\section{Types of programming language}
\label{\detokenize{chapters/motivation/language_types:types-of-programming-language}}\label{\detokenize{chapters/motivation/language_types:language-types}}\label{\detokenize{chapters/motivation/language_types::doc}}
\sphinxAtStartPar
A Computer Science purist might debate the details of the below slightly, but broadly there are 3 types of programming language. There are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Markup languages. Such as HTML (the ML stands for Markup Language), XML, LaTeX, Markdown, JSON, yaml.

\item {} 
\sphinxAtStartPar
Scripted (interpreted) languages. Such as Python, Matlab, PHP, PowerShell, Bash.

\item {} 
\sphinxAtStartPar
Compiled languages. Such as C, C++, C\#, Java, Rust.

\end{itemize}

\sphinxAtStartPar
(It’s fine to debate this. The aim at this point is to get to right ballpark, not to go into too much depth.)


\subsection{Markup languages}
\label{\detokenize{chapters/motivation/language_types:markup-languages}}
\sphinxAtStartPar
Markup languages are used for passing text and data around. They rely on having an interpreter which knows what the markup means. For example, in HTML, web browsers know to interpret

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{b}\PYG{p}{\PYGZgt{}}some text\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{b}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
as display “some text” in bold. In LaTeX, the markup for the same thing has a different syntax,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZbs{}textbf}\PYG{n+nb}{\PYGZob{}}some text\PYG{n+nb}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
JSON, yaml, and similar are for passing data around. For example, JSON stores key\sphinxhyphen{}value pairs as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Alex\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{ }\PYG{n+nt}{\PYGZdq{}office number\PYGZdq{}}\PYG{p}{:}\PYG{+w}{ }\PYG{l+m+mf}{4.018}\PYG{p}{,}
\PYG{+w}{ }\PYG{n+nt}{\PYGZdq{}wears glasses\PYGZdq{}}\PYG{p}{:}\PYG{+w}{ }\PYG{k+kc}{true}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
which a receiving programme or person can interpret as appropriate. Markup languages are thus very useful for formatting the inputs and outputs of programs in a way that other computer systems know how to use. (Aside: More details on types of programming language.)


\subsection{Interpreted languages}
\label{\detokenize{chapters/motivation/language_types:interpreted-languages}}
\sphinxAtStartPar
Interpreted languages run code by working through a series of commands, one line at a time. That is, they execute one line of code, get the results, then the next line, and so on. They’re widely used for tasks where there’s a fixed order to do things in. For example, in data analysis, first you load the data, then you do some filtering on the data to remove noise and outliers, then you transform the data to highlight the points of interest, then you plot the data, and so on.

\sphinxAtStartPar
These sorts of programs are generally quick and easy to write, but slow to run. It’s thus a trade\sphinxhyphen{}off. They are also relatively sensitive to having run\sphinxhyphen{}time errors that the user sees. If there’s a mistake on (say) line 50 of the code, the first 49 lines may run fine, and the code only errors out once it gets to line 50.


\subsection{Compiled languages}
\label{\detokenize{chapters/motivation/language_types:compiled-languages}}
\sphinxAtStartPar
Compiled languages convert commands into a format the computer can execute, for the entire program, before the code is executed. This process is known as compilation. It means that the code can be optimized, automatically, by the compiler before it is ever run.

\sphinxAtStartPar
The code thus tends to run more quickly than scripted code does. The compiler also checks for errors while it’s compiling. So, if line 50 is missing a “\}”, the compilation fails and you have to fix the issue and compile it again before the code can be run. In turn, this means that the code doesn’t fail while the user is running the program, and so the user never sees that there was an issue there.

\sphinxAtStartPar
In practice it’s common to use all of these together. Often we use a scripting language such as Python, which is relatively fast to write but slow to execute, to \sphinxstyleemphasis{glue} together computationally complex tasks which are written in a higher performance language. This gets the best of both worlds. Simple tasks can be done in a quick to write language like Python, while tasks that take a long time to run are written in a more highly optimized language.

\begin{sphinxadmonition}{note}{Asides}

\sphinxAtStartPar
Two minor asides are relevant here for completeness.

\sphinxAtStartPar
Firstly, technically markup is only for text. (So languages like HTML and Markdown.) JSON or yaml (as examples) for passing data around aren’t markup. I think it’s useful to badge them under the same heading of: a structured form for sending something around so the receiver knows what they’re receiving and what they need to do to interpret it; which I’ve called markup. In any case, the ML in yaml stands for markup language (with the exact meaning having changed over time).

\sphinxAtStartPar
Secondly, today, many interpreted languages use \sphinxstyleemphasis{Just\sphinxhyphen{}In\sphinxhyphen{}Time Compilation} to help them run faster. Rather than running purely line\sphinxhyphen{}by\sphinxhyphen{}line; when run, first a quick compilation is carried out to check for errors and any optimizations that can be performed, before it is then run line\sphinxhyphen{}by\sphinxhyphen{}line. If you have an error on line 50, the Just\sphinxhyphen{}In\sphinxhyphen{}Time Compilation will probably spot this, and refuse to run anything before it’s fixed. It’s a technique used to speed up the code, but interpreted code is usually still slower than a fully compiled language.
\end{sphinxadmonition}

\sphinxstepscope


\section{Our choices for this course}
\label{\detokenize{chapters/motivation/our_choices:our-choices-for-this-course}}\label{\detokenize{chapters/motivation/our_choices:motivation}}\label{\detokenize{chapters/motivation/our_choices::doc}}
\sphinxAtStartPar
Programming and software development are very large areas. There are lots of different programming languages, and software development environments that we could chose to study! Here we include some motivations for the choices that we’ve made in terms of languages. When we go over {\hyperref[\detokenize{chapters/software_development_tools:software-tools}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{software tools}}}}} we’ll give the motivations for the different tools we’re going to work with.


\subsection{Python and Rust}
\label{\detokenize{chapters/motivation/our_choices:python-and-rust}}
\sphinxAtStartPar
The course aims to give an introduction to both general purpose programming, and a lower level systems programming language.

\sphinxAtStartPar
For general purpose programming, Python is the obvious choice. It is very widely used, and commonly listed as the \sphinxhref{https://www.tiobe.com/tiobe-index/}{most widely used programming language}. It is used extensively for machine learning and for data science, as well as more general task automation. Many students will also be starting the course with some previous experience with Python from their school level studies.

\sphinxAtStartPar
For a lower level language, there is more debate as to the most suitable choice. C, C++, Java and similar are all widely used. Historically, we taught C. Before this we taught Java, and before that it was C. We now focus on Rust. This is due to \sphinxstyleemphasis{memory safety}. We will cover this more later in the course, but briefly, memory safety refers to ensuring that the program can only see areas of memory that are associated with that particular program. It’s relatively easy to accidentally write C programs that can access other memory locations and which can be exploited by malicious actors to run code or access data that they shouldn’t have access to.

\sphinxAtStartPar
The \sphinxhref{https://www.ncsc.gov.uk/}{National Cyber Security Centre}, and international counterparts, have called for code to have a \sphinxhref{https://media.defense.gov/2023/Dec/06/2003352724/-1/-1/0/THE-CASE-FOR-MEMORY-SAFE-ROADMAPS-TLP-CLEAR.PDF}{roadmap towards being memory safe}. Indeed they state “\sphinxstyleemphasis{Organizations should signal their demand for developers
trained in security and memory safety to colleges, universities, and educational
institutions.}”

\sphinxAtStartPar
\sphinxhref{https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html/}{Google estimate} that in 2024 24\% of security vulnerabilities in Android were due to memory safety issues. (Down from 76\% in 2019 due to their increased such of techniques such as switching to Rust.)

\sphinxAtStartPar
Rust as a programming language has been designed to help minimize memory safety issues. We are thus proactively using Rust to build in memory safe code into your practices from the outset.


\subsection{Shell scripting and C/C++}
\label{\detokenize{chapters/motivation/our_choices:shell-scripting-and-c-c}}
\sphinxAtStartPar
While the above languages represent the main focus of the course, some topics are needed around these in order to give you a solid grounding in programming.

\sphinxAtStartPar
We will meet the {\hyperref[\detokenize{chapters/computer_software/gui_and_cli:cli}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{terminal or command line interface}}}}} shortly. We use the command line extensively when programming, and \sphinxstyleemphasis{shell scripting} is the process of automating tasks for the command line. It’s important to be confident with the command line, and so we’ll spend some time developing familiarity with it.

\sphinxAtStartPar
Equally, there are billions of lines of C and C++ code that have been developed. These will continue to be used and developed for many years to come. While we’re going to focus on Rust, it’s important to have some familiarity with other compiled languages. It’s very likely you’ll encounter these languages in other courses at the University of Manchester, and potentially in industry if you go into a software development area. We have a small number of labs on these, to highlight some of the key features of the languages, and give you enough to get up and going if you encounter them in a different course and/or project.

\sphinxstepscope


\chapter{Computer hardware}
\label{\detokenize{chapters/computer_hardware:computer-hardware}}\label{\detokenize{chapters/computer_hardware:id1}}\label{\detokenize{chapters/computer_hardware::doc}}
\sphinxAtStartPar
This isn’t a course on computer architecture, but it’s useful to know a little about what is inside a modern computer (both hardware and software) as it shapes how we go about our programming. This section gives a brief introduction, sufficient for the depth of this course.

\sphinxAtStartPar
A high level diagram showing the parts of a computer system is shown below. There are multiple different bits:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The processor, which is the heart of the system, executes the commands we ask the computer to carry out. Consumer grade computers typically only have one processor in them, but high end machines may have more than one to increase performance and to improve resilience in case one fails. Inside most processors there is more than 1 core, with these multiple cores allowing multiple things to be executed at the same time. There are different architectures of processor available. x86\_64 from Intel/AMD, Arm (used in Apple computers and the Raspberry Pi), and RISC\sphinxhyphen{}V are all common. Generally, code compiled for one processor architecture will only run on that architecture, although programs that run on all platforms are also widely possible.

\item {} 
\sphinxAtStartPar
There is memory (known as RAM, or possibly a cache close to the processor, or registers in the processor) for storing data and variables while they are being actively worked on or used.

\item {} 
\sphinxAtStartPar
There is longer term memory, typically the hard drive, for storing data (for example when the computer is turned off) and data which won’t fit into the RAM.

\item {} 
\sphinxAtStartPar
There are a range of Input/Output (I/O) devices such as the screen and keyboard for interacting with the computer. These include a network port (wired or wireless) to connect to other devices.

\item {} 
\sphinxAtStartPar
There are specialist processing devices, in particular the graphics card. Graphics cards are very good at executing some types of tasks very quickly. A lot of machine learning uses the graphics card rather than the processor for doing the heavy lifting, as they are faster for this specialist task.

\item {} 
\sphinxAtStartPar
There are other computers connected across the network. These may provide more storage, or more processing power, or something else that helps the computer run.

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{computer_parts}.png}
\end{figure}

\sphinxAtStartPar
Each of these blocks represents a potential bottleneck when writing a program. For example, it could be that a program is I/O limited, where data can’t be passed into the program quickly enough (say as the data is coming from the Internet and the network connection is slow). Here, reducing the memory required for the program to run might be good to do, but it won’t help the program run any quicker. Alternatively, a program might be limited by how quickly the processor runs and can get through commands.

\sphinxAtStartPar
Whatever the bottleneck, there are techniques for reducing their impact. For example, to decrease the running time of a processor limited task, rather than asking users to buy a better processor(!), code can be \sphinxstyleemphasis{re\sphinxhyphen{}factored} to accomplish the same task in a different way. It’s not uncommon to try a few different ways of coding a particular function to see which works best. Alternatively, you can add \sphinxstyleemphasis{multi\sphinxhyphen{}threading} to the program, to allow the code to operate on more than one core (and processor) at the same time.

\sphinxAtStartPar
For the relatively simple programs we’ll be looking at in this course these limiting factors probably won’t present a big issue, and so you won’t need to think about what hardware the program is running on. Our code will thus generally be hardware agnostic. This won’t necessarily be the case when you move to more advanced topics, where you may need to think about what hardware your software is intended to run on and how you best optimize your coding for this hardware.

\sphinxAtStartPar
In general, the exception to the above is memory. For low level code, as we’ll get to in the second half of the course, managing the computer’s memory and thinking about where the data is stored, what has access to it, and how long the data is valid for (its \sphinxstyleemphasis{lifetime}) are important parts of the program. It’s likely that you’ll have to start thinking about memory, long before you have to start thinking about other aspects of how hardware might impact your code.

\sphinxstepscope


\chapter{Computer software}
\label{\detokenize{chapters/computer_software:computer-software}}\label{\detokenize{chapters/computer_software::doc}}
\sphinxAtStartPar
This is fundamentally a course on computer software, and writing it, and so there is more background to go over on this topic. Important is to have some familiarity with the \sphinxstyleemphasis{command line}. This is a text based interface for giving commands to a computer, and we’ll make a lot of use of.

\sphinxAtStartPar
We don’t assume you’re coming from a background with programming experience, and so we also go over some of the basic concepts we’ll need. Mainly \sphinxstyleemphasis{files} and \sphinxstyleemphasis{folders} which we use to help keep our work organized. We’ll also briefly go over the major operating systems and how they differ. The course is in principle cross\sphinxhyphen{}platform, it shouldn’t matter which operating system you’re using.

\sphinxAtStartPar
When we get into the later topics of {\hyperref[\detokenize{chapters/programming_fundamentals:programming-fundamentals}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{programming fundamentals}}}}} we’ll find there’s quite a lot more detail on how computers work, \sphinxstyleemphasis{behind the scenes}. You don’t need lots of this when you first start out, but as you write more advanced code you need to know more about how the computer is actually working.

\sphinxstepscope


\section{Major operating systems}
\label{\detokenize{chapters/computer_software/major_operating_systems:major-operating-systems}}\label{\detokenize{chapters/computer_software/major_operating_systems:operating-systems}}\label{\detokenize{chapters/computer_software/major_operating_systems::doc}}
\sphinxAtStartPar
When your computer starts it will generally load an \sphinxstyleemphasis{operating system}. The operating system gives the basic interface for interacting with the computer. There are a number of major and widely used operating systems available.

\sphinxAtStartPar
Computer code can be \sphinxstyleemphasis{cross\sphinxhyphen{}platform}, meaning that it will work on any of the major operating systems. Alternatively, code may make use of features specific to one operating system and so only work on that particular operating system. Code can also be \sphinxstyleemphasis{cross\sphinxhyphen{}compiled}. This means one operating system may be used while writing the code, while the code itself actually runs on a different operating system.


\subsection{Windows}
\label{\detokenize{chapters/computer_software/major_operating_systems:windows}}
\sphinxAtStartPar
Windows is a widely known and widely used operating system made by Microsoft. It is the most commonly used operating system for desktop/laptop like devices. It is based around a \sphinxstyleemphasis{desktop}, a \sphinxstyleemphasis{start} button, and a \sphinxstyleemphasis{taskbar} as shown in the figure below.

\sphinxAtStartPar
Pressing the start button brings up a list of programs that are available to run. Running programs are listed on the taskbar, allowing them to be switched between easily. The concept is that all of the different programs needed for a particular task are shown together on the taskbar. (For example, when writing a report, you might need Word to write the report, a web browser to look up information, a spreadsheet to look at results from an experiment, all at the same time.)

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{windows_desktop}.png}
\end{figure}


\subsection{macOS}
\label{\detokenize{chapters/computer_software/major_operating_systems:macos}}
\sphinxAtStartPar
macOS is made by Apple, and can only run on Apple devices. It is the second most common operating system for desktop/laptop type devices. It is based around a desktop, with a \sphinxstyleemphasis{dock} which shows the commonly used programs and running programs. The concept is that all instances of a particular program are shown under that program’s icon in the dock. So all Word documents under the Word icon, all web sessions under the browser icon, and so on.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{macos_desktop}.png}
\end{figure}

\sphinxAtStartPar
macOS is descended from a different operating system, known as BSD. In turn, BSD is descended from an operating system known as Unix. Linux (discussed below) also has its roots in Unix. Although there are a lot of differences today, this common ancestor operating system is why so many of the commands we’ll see in this course are the same for macOS/Linux, and something different for Windows.


\subsection{Linux}
\label{\detokenize{chapters/computer_software/major_operating_systems:linux}}
\sphinxAtStartPar
Linux is really refers to a family of operating systems rather than an individual one. There are many different Linux \sphinxstyleemphasis{distributions}, each of which is a slightly different operating system. Ubuntu, Debian, and Red Hat are well known distributions, although there are many more.

\sphinxAtStartPar
Linux is generally open source and free to download and install. It is the least common of the major desktop/laptop operating systems, but is very widely used in high performance computing and in computer servers. It’s thus very common to encounter when programming. It’s also the underlying operating system present in Chromebooks.

\sphinxAtStartPar
Linux is extremely configurable, and there are many different distributions, and so it can look very different depending on which desktop environment is being used. The figure below is for Mint Linux (which is based upon Ubuntu, which in turn is based upon Debian). This interface is conceptually very similar to Windows, with a taskbar.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{linux_desktop}.png}
\end{figure}

\sphinxAtStartPar
This course is intended to be cross\sphinxhyphen{}platform. Apart from a few cases where the behavior is unavoidably different, it shouldn’t matter whether you are using Windows, macOS, or Linux. For Linux though, we will give instructions assuming a Debian based distribution. For a Red Hat based distribution (e.g. CentOS, Fedora, Rocky) the commands to install programs will be different. Our tools (the dockerfile, the autograder, and similar) use Ubuntu.


\subsection{Real\sphinxhyphen{}time operating systems}
\label{\detokenize{chapters/computer_software/major_operating_systems:real-time-operating-systems}}
\sphinxAtStartPar
The above operating systems are are complex, multi\sphinxhyphen{}tasking operating systems. They are optimized for having multiple programs running at the same time, and often have multiple activities running in the background.

\sphinxAtStartPar
There is also a class of operating system known as \sphinxstyleemphasis{real\sphinxhyphen{}time operating systems} (RTOS). These are used, mainly with more embedded platforms than a standard desktop/laptop type device, when there are time critical constraints present. They are relatively common for low power sensor nodes, and Internet\sphinxhyphen{}of\sphinxhyphen{}Things devices which have a fixed, limited, set of tasks to undertake and also need to be able to respond to external inputs in a guaranteed timely manner.

\sphinxAtStartPar
\sphinxhref{https://www.freertos.org/}{FreeRTOS} and \sphinxhref{https://zephyrproject.org/}{Zephyr} are widely used examples. There is also Real\sphinxhyphen{}time Linux, for example \sphinxhref{https://ubuntu.com/real-time}{Real\sphinxhyphen{}time Ubunutu}.

\sphinxAtStartPar
We won’t make use of an ROTSs in this course, but mention them here for completeness. RTOSs can be very useful for the types of project undertaken by Electrical and Electronic Engineering students where power/size constraints mean a full desktop/laptop isn’t suitable, and where a full desktop\sphinxhyphen{}like operating system wouldn’t necessarily be fast enough to respond to user input in a timely manner due to background tasks also being run.


\subsection{No operating system}
\label{\detokenize{chapters/computer_software/major_operating_systems:no-operating-system}}
\sphinxAtStartPar
If working with a low power micro\sphinxhyphen{}controller such as an \sphinxhref{https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html}{STM32} or \sphinxhref{https://www.ti.com/microcontrollers-mcus-processors/msp430-microcontrollers/overview.html}{MSP430}, rather than a desktop/laptop computer, you might find that no operating system is present. These kinds of platform can run an RTOS, or they can be set to just run a code file directly. For example, they might have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{command1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{command2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{command3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The precise syntax of this isn’t important at the moment. The \sphinxcode{\sphinxupquote{%
\PYG{k}{while}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}%
}} loop will run continuously, executing \sphinxcode{\sphinxupquote{%
\PYG{n}{command1}\PYG{p}{(}\PYG{p}{)}%
}}, then \sphinxcode{\sphinxupquote{%
\PYG{n}{command2}\PYG{p}{(}\PYG{p}{)}%
}}, and then \sphinxcode{\sphinxupquote{%
\PYG{n}{command3}\PYG{p}{(}\PYG{p}{)}%
}} (and any others which are present), before returning to the start and running \sphinxcode{\sphinxupquote{%
\PYG{n}{command1}\PYG{p}{(}\PYG{p}{)}%
}} again, and so on. This make multi\sphinxhyphen{}tasking difficult, there’s no operating system to help manage doing more than one task at the same time. However, it is low overhead and simple for low complexity, low power, situations.

\sphinxstepscope


\section{User interfaces: graphical and the command line}
\label{\detokenize{chapters/computer_software/gui_and_cli:user-interfaces-graphical-and-the-command-line}}\label{\detokenize{chapters/computer_software/gui_and_cli:cli}}\label{\detokenize{chapters/computer_software/gui_and_cli::doc}}

\subsection{Graphical User Interfaces}
\label{\detokenize{chapters/computer_software/gui_and_cli:graphical-user-interfaces}}
\sphinxAtStartPar
Most computer systems we interact with as users have a Graphical User Interface (GUI). These are the buttons and icons and other areas that we can interact with via the keyboard, mouse, and other input methods. An example of the basic Windows GUI, which you’re probably familiar with, is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{desktop}.png}
\end{figure}

\sphinxAtStartPar
Different Apps and Programs are displayed in \sphinxstyleemphasis{windows}, which you can arrange to view multiple different things at the same time. Within each window, the App has buttons to control what it does, possibly areas to enter text, and so on. You interface with these via the keyboard, mouse, and possibly touch (if you have a touchscreen computer).

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{gui_windows}.png}
\end{figure}


\subsection{Command Line Interfaces}
\label{\detokenize{chapters/computer_software/gui_and_cli:command-line-interfaces}}
\sphinxAtStartPar
Before computers had GUIs, they had only a Command Line Interface (CLI) where commands had to be typed in. Computers still have the CLI, and the CLI is widely used for programming because it gives a lot of control. The instructions to the computer are written down, they don’t (say) rely on you clicking on the correct area of the screen.

\begin{sphinxadmonition}{note}{Aside}

\sphinxAtStartPar
You may also see people refer to a \sphinxstyleemphasis{Text User Interface} (TLI). For our purposes, these are a sub\sphinxhyphen{}set of Command Line Interfaces, and so we’ll only refer to Command Line Interfaces.
\end{sphinxadmonition}

\sphinxAtStartPar
In macOS or Linux you will find a pre\sphinxhyphen{}installed application called Terminal. In Windows there is Command Prompt (which is older) and Powershell (which is more recent and some copies of Windows may only have this). You can also install Windows Terminal from the Windows Store which lets you easily switch between different CLIs. Sometimes these modern CLIs are referred to as \sphinxstyleemphasis{Terminal Emulators}, as they’re not the core of the operating system any more they’re emulating what computers used to look like.

\sphinxAtStartPar
You can start these CLIs from the Start menu (or similar) as you would any other program. An example of Windows Terminal, giving access to the Command Prompt, PowerShell and a Linux terminal, is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{terminal}.png}
\end{figure}

\sphinxAtStartPar
We’re explore using these interfaces in the first lab. Briefly, lots of programs accept inputs at the command line, even if you don’t use it lots. For example, if running Windows, and you have the Chrome web browser installed (at the location used below) you can enter the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} \PYGZdq{}C:\PYGZbs{}Program Files\PYGZbs{}Google\PYGZbs{}Chrome\PYGZbs{}Application\PYGZbs{}chrome.exe\PYGZdq{} \PYGZhy{}\PYGZhy{}headless \PYGZhy{}\PYGZhy{}disable\PYGZhy{}gpu \PYGZhy{}\PYGZhy{}print\PYGZhy{}to\PYGZhy{}pdf\PYGZhy{}no\PYGZhy{}header \PYGZhy{}\PYGZhy{}print\PYGZhy{}to\PYGZhy{}pdf=\PYGZdq{}output.pdf\PYGZdq{} \PYGZdq{}input.html\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
to convert a HTML webpage to a PDF file. The \sphinxstylestrong{\textgreater{}} above represents the command prompt, showing where to enter the command. You don’t have to type it in. You can see it in the screenshot above, showing you where to enter commands.

\sphinxAtStartPar
In general, terminal windows have three \sphinxstyleemphasis{ports} associated with them:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Standard input. Usually commands coming from the keyboard.

\item {} 
\sphinxAtStartPar
Standard output. Usually displaying text to the terminal window.

\item {} 
\sphinxAtStartPar
Standard error. Where errors are displayed. This is generally the terminal window, but it might be mapped to a special error display, or to a log file.

\end{itemize}

\sphinxAtStartPar
As this course doesn’t look into GUI applications, we’ll use the terminal a lot for providing input and displaying output to our programs, and (when they inevitably occur!) errors will be displayed here too.

\sphinxstepscope


\section{Files, folders, and filesystems}
\label{\detokenize{chapters/computer_software/files_and_folders:files-folders-and-filesystems}}\label{\detokenize{chapters/computer_software/files_and_folders:files-folders-filesystems}}\label{\detokenize{chapters/computer_software/files_and_folders::doc}}
\sphinxAtStartPar
Code files can be very long! The labs for this course are intended to take 2\sphinxhyphen{}3 hours each, and so we’re constrained to looking at relatively small programs. Typically a hundred lines of code or so. Real programming projects have much more than this. For example, the Chrome web browser is estimated to have \sphinxhref{https://interestingengineering.com/lists/whats-the-biggest-software-package-by-lines-of-code}{6\sphinxhyphen{}7 million lines of code}. When having so much code, its important to keep it organized. To do this, we split the code into \sphinxstyleemphasis{files} and store files in \sphinxstyleemphasis{folders}.

\begin{sphinxadmonition}{note}{Aside}

\sphinxAtStartPar
The concepts of files and folders come from the \sphinxstyleemphasis{desktop metaphor}. When computers first became widely used in the 1980’s, lots of terms were selected to make them familiar to people who had only ever previously worked on a physical desk, with pens, paper, books and similar. Back then, there were lots of physical pieces of paper (files), and means for grouping these together such as ring binders and filing cabinets (folders). This is why your computer has a \sphinxstyleemphasis{desktop} with \sphinxstyleemphasis{files} on it, it mirrors a physical desk. Of course, this doesn’t make a huge amount of sense today. Many people just have a computer on their physical desk!
\end{sphinxadmonition}


\subsection{Files}
\label{\detokenize{chapters/computer_software/files_and_folders:files}}
\sphinxAtStartPar
The basic unit of storing a document on a computer is a \sphinxstyleemphasis{file}. Each file has a name, known as the filename. This is usually something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{my\PYGZus{}file\PYGZus{}name.txt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here my\_file\_name is the \sphinxstyleemphasis{basename}, what you want to call the file. Hopefully this is something meaningful to you as the user. The .txt is the \sphinxstyleemphasis{extension}. This tells the computer what type of file is present. This is also known as the \sphinxstyleemphasis{format}. A file can be perfectly valid even if no extension is present, but an extension helps tell the computer, and you, what kind of information is in the file.

\sphinxAtStartPar
For example, .docx indicates this file is for a Word document. .png indicates it contains a picture. There are lots of different file types, and not every program can open every type of file. Note that sometimes the extension is hidden by default. It may be present, but the interface just doesn’t display it unless you change the settings. (This is the default behavior in the Windows GUI.)

\sphinxAtStartPar
When programming, we often use files with a .sh, .py, .rs, .c, .cpp, extension, to indicate which programming language is being used for the code in that file.


\subsection{Folders}
\label{\detokenize{chapters/computer_software/files_and_folders:folders}}
\sphinxAtStartPar
For any practical project, you probably need several different files to store all of the information that’s needed. For example, when writing a report you may have a .docx Word file that actually contains the report. You may have several .png or .jpg pictures that you took and need to be included in the report to show your work. You may also have a spreadsheet document in .xlsx or .csv format that stores the results from an experiment.

\sphinxAtStartPar
The basic organizational unit for storing files is a \sphinxstyleemphasis{folder}. Folders are also known as \sphinxstyleemphasis{directories}. Files are stored in folders. You can also put folders into folders to help organize things into different levels. For example, the figure below shows the files and folders used for these notes (which you can view if you click the GitHub (\sphinxincludegraphics[width=20\sphinxpxdimen]{{GitHub_Invertocat_Dark}.svg}) icon at the top of the page). There is a folder called notes\sphinxhyphen{}part1. In here are several folders (.github, .venv, docs). The notes are stores in files with .rst extensions within the chapters folder.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{tree_view}.png}
\end{figure}


\subsection{File systems}
\label{\detokenize{chapters/computer_software/files_and_folders:file-systems}}
\sphinxAtStartPar
Each file and folder has an address on your computer to locate it. The address to a file is also known as the file \sphinxstyleemphasis{path}. The way in which addresses work varies depending on which operating system you’re using.


\subsubsection{Windows}
\label{\detokenize{chapters/computer_software/files_and_folders:windows}}
\sphinxAtStartPar
Addresses begin with a letter, followed by a colon \sphinxcode{\sphinxupquote{%
\PYG{g+go}{:}%
}}. Folders are separated by backslashes \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZbs{}}%
}}. For example this might be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{C:\PYGZbs{}Users\PYGZbs{}alex\PYGZbs{}hello\PYGZus{}world.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can also see this location (C:\textbackslash{}Users\textbackslash{}alex\textbackslash{}) if we use the File Explorer GUI. It contains a file called hello\_world.py.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{file_explorer}.png}
\end{figure}

\sphinxAtStartPar
By convention, the letter \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} refers to the hard drive in the computer being used. You may see other letters being used. For example, students logged in to computers at the University of Manchester also have a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{P:\PYGZbs{}}%
}} drive. This is a \sphinxstyleemphasis{network drive}. The \sphinxcode{\sphinxupquote{%
\PYG{g+go}{P:\PYGZbs{}}%
}} drive storage isn’t on the computer being used, it’s connected via the Internet and so given a different address letter.

\sphinxAtStartPar
This arrangement is very common for shared computers, although different places may use different letters. For shared devices, you want files to be accessible no matter which computer you log in to. You can’t do this if the files are only stored on the one physical computer. If you plug in a USB thumb drive, it will be given another letter, which may vary from computer to computer.

\sphinxAtStartPar
Using a drive letter is a form of \sphinxstyleemphasis{physical addressing}. It forces you to think about \sphinxstyleemphasis{where} you are storing the files. Is it on this computer, a thumb drive, or on a network computer, and so on.

\sphinxAtStartPar
In many programming languages the backslash character \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZbs{}}%
}} has a special meaning and can’t be used directly. It’s thus common to enter a Windows path using two backslashes, i.e. as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{C:\PYGZbs{}\PYGZbs{}Users\PYGZbs{}\PYGZbs{}alex\PYGZbs{}\PYGZbs{}hello\PYGZus{}world.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
or with forward slashes \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/}%
}} as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{C:/Users/alex/hello\PYGZus{}world.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
These aren’t how Windows represents a path, it uses a single backslash, but may be the syntax needed in a programming file to represent the same thing.


\subsubsection{macOS and Linux}
\label{\detokenize{chapters/computer_software/files_and_folders:macos-and-linux}}
\sphinxAtStartPar
Addresses begin with a forward slash \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/}%
}}. Folders are separated by forward slashes \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/}%
}}. For example this might be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/Users/alex/hello\PYGZus{}world.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/home/alex/hello\PYGZus{}world.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
macOS usually puts users’ files in \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/Users/username}%
}}, while Linux puts them in \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/home/username}%
}}.

\sphinxAtStartPar
Just \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/}%
}} is a valid address. It is known as the \sphinxstyleemphasis{root} of the filesystem.

\sphinxAtStartPar
This is a form of \sphinxstyleemphasis{logical} addressing. You put the data in the most sensible location, without necessarily thinking about where the data is physically put. In principle

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/home/alex/}
\end{sphinxVerbatim}

\sphinxAtStartPar
and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/home/casson/}
\end{sphinxVerbatim}

\sphinxAtStartPar
could be pointing to two different hard drives. The actual storage location has been abstracted away.


\subsubsection{Cloud storage}
\label{\detokenize{chapters/computer_software/files_and_folders:cloud-storage}}
\sphinxAtStartPar
At the University of Manchester our cloud storage provider is Microsoft OneDrive. Cloud storage changes the statements above a little.

\sphinxAtStartPar
On Windows, you will have a folder called

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{C:\PYGZbs{}Users\PYGZbs{}alex\PYGZbs{}OneDrive \PYGZhy{} The University of Manchester}
\end{sphinxVerbatim}

\sphinxAtStartPar
or similar. (There will be similar locations on macOS and Linux, but we’ll only give the Windows example for brevity here.) Files in the OneDrive folder are on the \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} drive. That is, they are on the hard drive of the computer being used.

\sphinxAtStartPar
At the same time, OneDrive will automatically copy the files to the Cloud. This means that they are backed up automatically, and so if anything happens to your computer you’ll still have all of your work. It also means that the files will be automatically available on any computer which has access to your OneDrive account.

\sphinxAtStartPar
(There’s also the option of having the file online by default. That is, Windows sees the file in the \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} drive as usual, but to save disk space it isn’t actually kept on the computer. It’s kept on the Cloud and downloaded when needed.)

\sphinxAtStartPar
You can access files in OneDrive using the same \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} address as you would for any other file.


\subsubsection{Absolute vs. relative addresses}
\label{\detokenize{chapters/computer_software/files_and_folders:absolute-vs-relative-addresses}}
\sphinxAtStartPar
The addresses given above, starting with \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} or \sphinxcode{\sphinxupquote{%
\PYG{g+go}{/}%
}} are \sphinxstyleemphasis{absolute} addresses. They start from the root of the computer being used and everything is given a full address from that starting point.

\sphinxAtStartPar
You can also have \sphinxstyleemphasis{relative} addresses. That is, an address of a file or folder, as steps from a current location or file or folder.

\sphinxAtStartPar
Giving examples for macOS/Linux using forward slashes,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{./}
\end{sphinxVerbatim}

\sphinxAtStartPar
represents the current folder. Two dots

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{../}
\end{sphinxVerbatim}

\sphinxAtStartPar
represents the folder one level up. That is, the folder containing the current location or file or folder. \sphinxcode{\sphinxupquote{%
\PYG{g+go}{../../}%
}} is two levels up, and so on.

\sphinxAtStartPar
Showing the same \sphinxstyleemphasis{tree view} of the files/folders for these notes that we saw earlier on this page

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{tree_view}.png}
\end{figure}

\sphinxAtStartPar
from \sphinxcode{\sphinxupquote{%
\PYG{g+go}{files\PYGZus{}and\PYGZus{}folders.rst}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{g+go}{gui\PYGZus{}and\PYGZus{}cli.rst}%
}} is in the same folder and so can be accessed with the relative address

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{./gui\PYGZus{}and\PYGZus{}cli.rst}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{our\PYGZus{}choices.rst}%
}} is up one level, and then in a different folder called motivation. From \sphinxcode{\sphinxupquote{%
\PYG{g+go}{files\PYGZus{}and\PYGZus{}folders.rst}%
}}, our\_choices.rst can be accessed with the relative address

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{../motivation/our\PYGZus{}choices.rst}
\end{sphinxVerbatim}


\subsection{Best practices}
\label{\detokenize{chapters/computer_software/files_and_folders:best-practices}}

\subsubsection{Where should I put my files?}
\label{\detokenize{chapters/computer_software/files_and_folders:where-should-i-put-my-files}}
\sphinxAtStartPar
The short answer is in your University provided OneDrive. This will ensure that the files will be automatically backed up, and automatically available on any computer which has access to your OneDrive account.

\sphinxAtStartPar
You may find that some, mainly older, programs don’t like files which are stored in OneDrive. Your second choice location should be your \sphinxcode{\sphinxupquote{%
\PYG{g+go}{P:\PYGZbs{}}%
}} drive. This is a network drive, and the storage is maintained for you by IT. That means it’s automatically backed up, and available on any University computer.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{%
\PYG{g+go}{C:\PYGZbs{}}%
}} drive should be the location of last resort. Files here are only on the computer you’re using at the time. If you switch to a different computer, or you lose/damage the computer, your files will be lost (unless you’ve taken some other steps to back them up).


\subsubsection{How much filing to do}
\label{\detokenize{chapters/computer_software/files_and_folders:how-much-filing-to-do}}
\sphinxAtStartPar
When programming, you’ll quickly find that you actually have quite a few files, even for simple programs. Indeed, it’s common for the programming tools to automatically make a number of files and folders to store additional information about your program, even if your program is fundamentally only in one file.

\sphinxAtStartPar
If you don’t keep any track at all of what you put where, it’s easy to lose files \sphinxhyphen{} as in, they’re there, you just don’t know where. Or, to have multiple copies of the same underlying file.

\sphinxAtStartPar
You can of course search to find files, but when you have lots of files with similar names and/or content this can be quite hard. It is worth spending some time to organize your files. Wherever you put it, we would recommend making an EEEN11202 folder, and then having a folder for each lab within that outer folder.

\sphinxstepscope


\chapter{Software lifecycle}
\label{\detokenize{chapters/software_lifecycle:software-lifecycle}}\label{\detokenize{chapters/software_lifecycle::doc}}
\sphinxAtStartPar
The software lifecycle refers to us considering all of the steps involved in writing, deploying, and maintaining code. There are international standards that set out the steps that people/teams/organizations should go through:
\begin{itemize}
\item {} 
\sphinxAtStartPar
ISO/IEC/IEEE 12207 covers general software.

\item {} 
\sphinxAtStartPar
IEC 62304 covers medical device software.

\end{itemize}

\sphinxAtStartPar
Generally, the higher risk the software (e.g. for medical devices, for planes vs. for toasters, for TVs) the more steps, documentation, and testing are required.

\sphinxAtStartPar
We won’t go through these international standards in detail, but will briefly overview the steps in the following sections. Some will come across as common sense, but as the saying goes, “\sphinxstyleemphasis{common sense isn’t always that common}”. It’s easy to skip some steps, or to do them too briefly, and build up problems that make the code hard to maintain.

\sphinxstepscope


\section{Requirements capture}
\label{\detokenize{chapters/software_lifecycle/requirements_capture:requirements-capture}}\label{\detokenize{chapters/software_lifecycle/requirements_capture::doc}}
\sphinxAtStartPar
The first step is to have a good understanding of what functionality the program has to have. This includes an understanding of what constraints are present.

\sphinxAtStartPar
Documenting the requirements or specifications, before you start, is essential for any project. This is important to ensure that everybody is on the same page, and to define what success looks like and how you will know whether you’ve achieved it or not. You don’t want cases where (say) you think your software only has to run on Windows, but your customer thinks it has to run on both Windows and macOS. Or (say) a case where you’re detecting number plates from vehicles in a car park, and you think this only covers cars but your customer thinks this covers both cars and motorbikes. Or, you think you need to detect 99\% of the number plates correctly in order for the software to be successful, but your customer thinks it needs to be 99.9\%.

\sphinxAtStartPar
You can always change the requirements later on if the project evolves in scope, but this is changing from a fixed established base, and you can ask for more time or money or resources to support the change. In the example above, the software that the customer wants is likely to take much longer to develop and test; and so it will cost more money. It’s very common for clients to implicitly or explicitly want feature creep. That is, more and more features to be added but without giving you any more time or money for adding them. Having a formal requirements capture, that they’ve agreed to in advance, helps stop this from happening.

\sphinxAtStartPar
Sometimes there are factors that you won’t know the answer to until you have an initial proof of concept in place and can do some preliminary tests. (In the example above, preliminary tests might show that 90\% is the best you can get in real\sphinxhyphen{}world settings so the performance target will need revising.) Sometimes things are just overlooked. (In the example above, is run time important?) There are formal techniques to guide requirements capture and help make sure that you don’t forget any important factors. Overall though, the most important thing is to write down the requirements that you do have so that they are fixed and agreed upon as best possible.

\sphinxstepscope


\section{Software architecture}
\label{\detokenize{chapters/software_lifecycle/software_architecture:software-architecture}}\label{\detokenize{chapters/software_lifecycle/software_architecture:id1}}\label{\detokenize{chapters/software_lifecycle/software_architecture::doc}}
\sphinxAtStartPar
Software architecture refers to how you choose to split up your code and implement the required functionality. You could put everything in one big file, but that probably isn’t the best way to do it! Usually we split the code up by function.

\sphinxAtStartPar
Continuing our example of detecting car number plates, maybe you have one unit of code which identifies where a number plate is in a camera picture, and another unit of code that does letter/number recognition on this. Each part has its own distinct aim, and they can potentially be developed separately (for example by different developers) before being brought together.

\sphinxAtStartPar
There are lots of decisions that need to be made here. How do the two bits of code talk to each other? For the code which identifies where a number plate is, is the output a set of coordinates telling the other function where to look, or is it an image which has been cropped from the main picture to show just the area of interest? Both are potentially fine, you just need to agree which you’re doing.

\sphinxAtStartPar
Defining the architecture of software typically involves:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Within the overall goal of the program, defining what the main functions are and how these will be grouped together.

\item {} 
\sphinxAtStartPar
Defining what the interfaces between these different functions will be.

\end{itemize}

\sphinxAtStartPar
For a large problem, this then gives you a high level blueprint to build your more detailed code against. In the same way that you wouldn’t start building a house without a reasonably detailed plan of what you’re going to build, you shouldn’t start writing complicated code without a reasonably detailed plan of what it’s going to look like. It helps makes the task more manageable by breaking it down into smaller chunks, and makes it easier to identify where in the code particular functionality is implemented (because you can look it up in the architecture rather than the more detailed code).

\sphinxAtStartPar
Again, the architecture wants to be written down, so that everybody knows what it is they’re trying to build. Design it, and then code it. Not the other way round. (Any architecture will probably be iterated several times during the process of actually writing the code, adding more detail each time, and that’s fine.)

\sphinxstepscope


\section{Testing and debugging}
\label{\detokenize{chapters/software_lifecycle/testing_and_debugging:testing-and-debugging}}\label{\detokenize{chapters/software_lifecycle/testing_and_debugging::doc}}
\sphinxAtStartPar
Very few programs work first time! This could be due to a simple mistake like a typo, or due to something quite subtle that you weren’t anticipating happening. Often a program will largely do what you want, but in some cases will crash or do something unexpected, and these corner cases need investigating. Debugging is the process of going through your code to see what happens in particular cases, and resolving issues so that the code works satisfactorily.

\sphinxAtStartPar
You’ll soon find that debugging takes as long, if not longer, than writing the code in the first place! Some engineers specialize in verification and validation. That is, testing code rather than developing it in the first place.

\sphinxAtStartPar
There are lots of tools and techniques to help you with testing and debugging, and you’ll use some in this course.

\sphinxstepscope


\section{Release, support, maintenance, and bug fixes}
\label{\detokenize{chapters/software_lifecycle/release:release-support-maintenance-and-bug-fixes}}\label{\detokenize{chapters/software_lifecycle/release::doc}}
\sphinxAtStartPar
Once all of your development has been done, and the code compiled and tested, an end product can be shipped to customers. In any non\sphinxhyphen{}trivial project, they’ll probably find more bugs! Testing is hard, and if your software is being used on thousands or millions of devices, each with a slightly different setup, it’s extremely hard to detect everything in advance. (This isn’t an excuse for shipping poor quality, bug\sphinxhyphen{}riddled code, just pragmatism. I’m sure we’ll all familiar with encountering bugs in programs we use on a computer.)

\sphinxAtStartPar
An important part of the software lifecycle is thus supporting your application after it’s been released. Typically programs are supported for a number of years, and customers can look up how long this is. Within the support period, new versions will be released, with bug fixes, possibly some small feature updates, and any security related updates. After the support period, the software falls out of support and the customer needs to get (possibly buy) a new version if they want to get the latest fixes. It’s not uncommon for customers to pay more money for longer support periods, so that they can get bug and security fixes without having to completely update or change the software.

\sphinxAtStartPar
This support and maintenance needs to be factored in when planning a software project. It may need fewer resources (people, money) than making the program in the first place, but it’s going to need some. Writing code which is easy to read and maintain is very important, as it may not be the original writer who has to go in and hunt down obscure bugs many years later!

\sphinxstepscope


\section{Documentation}
\label{\detokenize{chapters/software_lifecycle/documentation:documentation}}\label{\detokenize{chapters/software_lifecycle/documentation::doc}}
\sphinxAtStartPar
Documentation comes towards the end of the list here, but really it underpins all of the aspects of writing software. The code, the .c file(s), doesn’t stand in isolation. It’s paired with documentation which describes the requirements, the architecture, the testing strategy and results, and so on.

\sphinxAtStartPar
Writing a program is a design task \sphinxhyphen{} there are usually lots of different ways of achieving the same thing. Documentation helps others to understand how you chose to do it, and why you chose that way. Someone can probably work it out from looking at the code, but that’s a lot of work! It’s much easier for the original author to write down their thinking and decisions.

\sphinxAtStartPar
Remember that the person maintaining your code may in fact be you in the future! If you spend 6 months working on a different project, and then come back to do some bug fixes on a piece of code, almost certainly you’ll have forgotten a lot of details on why things were done the way they were. Future you will thank you for having some good documentation.

\sphinxstepscope


\section{Quality management}
\label{\detokenize{chapters/software_lifecycle/quality_management:quality-management}}\label{\detokenize{chapters/software_lifecycle/quality_management::doc}}
\sphinxAtStartPar
Generally, all of the above steps will be wrapped in a Quality Management Framework. That is, you’ll have a process for testing your code. You’ll have a process for checking the security of your code. You’ll have a process for capturing the requirements. A quality management system gets you to write down what each of these processes is, and how you sign off that they’ve been done. The quality management approach is thus a wrapper around the documentation you put in place to support the software lifecycle.

\sphinxAtStartPar
There are international standards for how to implement quality management, mainly:
\begin{itemize}
\item {} 
\sphinxAtStartPar
ISO 9001 for general systems.

\item {} 
\sphinxAtStartPar
ISO 13485 for medical devices.

\end{itemize}

\sphinxAtStartPar
For safety critical applications, independent auditors will look at your quality control processes, that they’re up to standard, and that you’ve followed them, before letting you sell your software. Even for less critical applications, it’s often beneficial to be certified against ISO 9001 to show that good attention to quality is present. This will make customers more likely to choose you.

\sphinxAtStartPar
A focus on quality and signing off that parts have been tested appropriately won’t mean that your software is bug free. That’s not a realistic expectation for any non\sphinxhyphen{}trivial project. It will, help ensure that the impact of any residual bugs is small. Moreover, if something goes wrong, the documentation helps you identify what went wrong and why. You can then change the quality management process so that similar issues are captured in the future and won’t happen again. This continuous improvement is particularly important for shipping high quality products that customers want to buy and trust.

\sphinxstepscope


\chapter{Software development tools fundamentals}
\label{\detokenize{chapters/software_development_tools:software-development-tools-fundamentals}}\label{\detokenize{chapters/software_development_tools:software-tools}}\label{\detokenize{chapters/software_development_tools::doc}}
\sphinxAtStartPar
Writing software is hard. There are lots of ways that code might not do exactly what you want, or might have bugs or other issues. For some people it’s a part time activity, but for many people it’s a full time job that they’re paid for, and that customers pay a lot of money for. It thus shouldn’t be surprising that there are lots of tools that have been created to help with writing software.

\sphinxAtStartPar
Fundamentally, code is a usually a piece of text that you can edit in many different programs. However we strongly recommend using dedicated tools that have been made for writing code. These contain lots of functions (and we’re only really going to scratch the surface) for helping to ensure you write high quality code, and to help you debug your code when things go wrong.

\sphinxAtStartPar
This section provides a brief walk though of some of the most common software development tools. There are quite a few sub\sphinxhyphen{}topics here. The aim isn’t necessarily for you to be an expert on all of these by the end of this course.

\sphinxAtStartPar
For each sub\sphinxhyphen{}topic we’ll give some information on the extent to which we’re going to use it in this course, and so the extent to which you need to know it (for the exam and similar). The other sub\sphinxhyphen{}topics are more to give you a starting point for if you do want to go deeper in your own time.

\sphinxstepscope


\section{Integrated Development Environments (IDEs)}
\label{\detokenize{chapters/software_development_tools/ide:integrated-development-environments-ides}}\label{\detokenize{chapters/software_development_tools/ide::doc}}
\sphinxAtStartPar
There isn’t one single tool that does everything from entering your code, compiling your code, debugging your code, applying version control, and so on. Instead we rely on lots of different tools working together. We bring these different tools together in an \sphinxstyleemphasis{Integrated Development Environment} (IDE) which gives easy access to all of the different tools in one place.

\sphinxAtStartPar
There are lots of different IDEs, with different strengths and weaknesses, and some paid for and some free. Major ones which you might hear about include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Visual Studio. This is only for development on Windows.

\item {} 
\sphinxAtStartPar
Xcode. This is only for development on macOS.

\item {} 
\sphinxAtStartPar
Eclipse. This is a cross\sphinxhyphen{}platform IDE.

\end{itemize}

\sphinxAtStartPar
We’re going to use the \sphinxhref{https://code.visualstudio.com/}{VSCode} IDE. (Don’t confuse VSCode with Visual Studio. Both are made by Microsoft, both have similar names, and both are installed on the University computers, but they are different programs.)

\sphinxAtStartPar
In general VSCode is a bare bones IDE (it’s more an advanced text editor) but it is a good starting point and is very widely used. The other IDEs listed above are much more fully featured with many capabilities, but that makes them a bit overkill for starting out where we won’t be using many of these capabilities.

\sphinxAtStartPar
You’ll learn how to use VSCode in detail in the labs, but the screenshot below shows an example of how it brings together multiple different tools in a GUI to let you easily access them.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{ide}.png}
\end{figure}

\sphinxAtStartPar
Note that there’s a terminal built in to this GUI. You don’t have to start a separate one. That is, when you start VSCode it will automatically give you a command line for entering commands into.

\sphinxAtStartPar
Remember that the VSCode environment is very configurable, and exactly what is displayed will vary depending on which \sphinxstyleemphasis{Extensions} you have installed, and which programming language you’re using. Don’t worry if yours looks different or doesn’t have some of the options shown above.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’re going to use VSCode. We’ll expect you to know how to use this, including in the exam. You’re welcome to use a different IDE if you would like, but it will limit the extent to which we’ll be able to help \sphinxhyphen{} we don’t know every detail about every IDE that’s out\sphinxhyphen{}there, and haven’t tested the course notes against them.
\end{sphinxadmonition}

\sphinxstepscope


\section{Comments}
\label{\detokenize{chapters/software_development_tools/comments:comments}}\label{\detokenize{chapters/software_development_tools/comments::doc}}
\sphinxAtStartPar
Comments allow you to add non\sphinxhyphen{}executable information into your code. The are intended for the developer (you or another team member working on making, supporting or updating the code). Generally they are used for explaining what the code is doing and why, to keep track of what this unit of code is for, and to explain anything which might not be obvious. Sometimes they are used to deactivate code that you have written, but don’t want to be part of the program at the moment for whatever reason.

\sphinxAtStartPar
Typically comments represent \sphinxhref{https://ieeexplore.ieee.org/abstract/document/5070980}{about 20\% of the lines of code that are actually written}. The form a substantial part of any program. Comments aren’t a substitute for good documentation though. They can usually only be text (no diagrams or similar) and they sit at a particular place in your code and so generally explain what’s happening only there, rather than giving the big picture. Nevertheless, comments are an essential part of any code.

\sphinxAtStartPar
In Python, lines that start with a hash \sphinxcode{\sphinxupquote{%
\PYG{c+c1}{\PYGZsh{}}%
}} are comments. In Rust, lines that start with two forward slashes \sphinxcode{\sphinxupquote{%
\PYG{c+c1}{//}%
}} are comments. Comments can start at any point during a line of code.

\sphinxAtStartPar
Examples of Rust comments might be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// This is a comment at the start of the file.}
\PYG{c+c1}{// We usually include some lines at the top of a file}
\PYG{c+c1}{// to explain what the code is for, what it\PYGZsq{}s trying to do.}
\PYG{c+c1}{// This usually includes who wrote it, a license}
\PYG{c+c1}{// a copyright statement, and so on.}

\PYG{k}{fn}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kd}{let}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// comment in\PYGZhy{}line with code.}
\PYG{+w}{                }\PYG{c+c1}{// This code is run, the}
\PYG{+w}{                }\PYG{c+c1}{// comment helps explain what it does}

\PYG{+w}{    }\PYG{c+c1}{// let i = 1; // this code is commented out}
\PYG{+w}{                  }\PYG{c+c1}{// It won\PYGZsq{}t run}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ll expect you to use suitable comments to document and explain your code. You might lose marks in the lab tasks and/or in the exam if you don’t have any comments present.
\end{sphinxadmonition}

\sphinxstepscope


\section{Docstrings and doctests}
\label{\detokenize{chapters/software_development_tools/docstrings:docstrings-and-doctests}}\label{\detokenize{chapters/software_development_tools/docstrings::doc}}
\sphinxAtStartPar
Comments sit alongside code and are intended (mainly) for the developer(s) of the code. In addition to comments, many programming languages support \sphinxstyleemphasis{docstrings}. These are inside the code file, but are intended for the \sphinxstyleemphasis{user} of the code. They may contain instructions on how to use the code, examples of the different options that are possible, and so on.

\sphinxAtStartPar
Docstrings thus complement comments, being aimed for a different audience. Rather than the user opening the code file, there is often {\hyperref[\detokenize{chapters/software_development_tools/documentation_tools:documentation-tools}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{another tool}}}}} that displays docstrings to the user via a nicer interface.

\sphinxAtStartPar
In Python docstrings are blocks of text inside three apostrophes \sphinxcode{\sphinxupquote{%
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}%
}}, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} This is a docstring.}
\PYG{l+s+sd}{Text and code in this block will be included in documentation.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{c+c1}{\PYGZsh{} This is a comment. It won\PYGZsq{}t be included in automatically generated documentation.}
\end{sphinxVerbatim}

\sphinxAtStartPar
In Rust the equivalent uses three forward slashes \sphinxcode{\sphinxupquote{%
\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}%
}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{/// This is a docstring.}
\PYG{l+s+sd}{/// Text and code in this block will be included in documentation.}
\PYG{o}{..}\PYG{p}{.}
\PYG{c+c1}{// This is a comment. It won\PYGZsq{}t be included in automatically generated documentation.}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this type of documentation for the user, it’s often useful to give some examples. Of course it’s important that these examples are correct! \sphinxstyleemphasis{doctests} are a type of {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:unit-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{unit testing}}}}} where the code given inside a docstring is tested to see whether it works (as opposed to testing the code in the main file).

\sphinxAtStartPar
In Rust, blocks of code which are inside three apostrophes \sphinxcode{\sphinxupquote{%
\PYG{l+s+sc}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}%
}}, and also inside a docstring, can be tested using doctest tools. An example in Rust code might be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{/// This is a dockstring.}
\PYG{l+s+sd}{/// Text and code in this block will be included in documentation.}
\PYG{l+s+sd}{/// ```}
\PYG{l+s+sd}{/// let i = 0;}
\PYG{l+s+sd}{/// i = i + 2;}
\PYG{l+s+sd}{/// ```}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We will have examples of docstrings and and a handful of doctests. We expect you to know that they exist, and to use them where appropriate.
\end{sphinxadmonition}

\sphinxstepscope


\section{Documentation tools}
\label{\detokenize{chapters/software_development_tools/documentation_tools:documentation-tools}}\label{\detokenize{chapters/software_development_tools/documentation_tools:id1}}\label{\detokenize{chapters/software_development_tools/documentation_tools::doc}}
\sphinxAtStartPar
Generally comments are quite low level, giving details on exactly what that piece of code is aiming to do and any hints needed to understand how it works and complicated operations. Docstrings sit at a level above this, giving details on how to use the code.

\sphinxAtStartPar
In contrast, documentation is a level higher still, explaining the overall architecture and design choices made.

\sphinxAtStartPar
You can just write documentation in a word processor such as Microsoft Word or Google Docs and store the file(s) together with the source code for your program. Alternatively, there are lots of dedicated tools available to help you write and maintain documentation. These tools can also help display docstrings in a more user friendly manner, so the user isn’t looking at the source code for the program.

\sphinxAtStartPar
As one example, \sphinxhref{https://www.sphinx-doc.org/en/master/}{Sphinx} takes documentation written as text and converts it to be an interactive website which can include code examples and other features. It is used in website such as \sphinxhref{https://about.readthedocs.com/}{Read the Docs} which is commonly used to share documentation for open source programs. Alternatively, \sphinxhref{https://www.doxygen.nl/}{DOxygen} takes the code file, including comments and docstrings, and helps convert them to be a website, which can include text and code, and have hyperlinks to move between different functions.

\sphinxAtStartPar
The different tools available each have their own syntax and detailed methods of using them.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
For this course, we don’t expect you to use, or have any specific knowledge on these types of documentation tools.

\sphinxAtStartPar
If interested, for these notes, Parts 0, 1 and 2 are written using \sphinxhref{https://www.sphinx-doc.org/en/master/}{Sphinx}. These are the more Python parts of the notes, and so the documentation is using Sphinx as a tool written in Python. Part 3, focusing more on Rust, is written using \sphinxhref{https://rust-lang.github.io/mdBook/}{mdBook}, a documentation tool written in Rust.

\sphinxAtStartPar
For all parts of the notes you can click on the GitHub (\sphinxincludegraphics[width=20\sphinxpxdimen]{{GitHub_Invertocat_Dark1}.svg}) icon at the top of the page if you want to see the source code for how we’ve made use of these tools.
\end{sphinxadmonition}

\sphinxstepscope


\section{Static code analysis}
\label{\detokenize{chapters/software_development_tools/static_code_analysis:static-code-analysis}}\label{\detokenize{chapters/software_development_tools/static_code_analysis::doc}}
\sphinxAtStartPar
Static code analysis refers to checking your code for errors, before you run the code. This can avoid you wasting time trying to run code which has known issues or other reasons why it might not work. Remember, our simple examples will likely run or compile in a few seconds, but real programs with thousands or millions of lines of code might take hours or more to compile, and so failed compilations can be a real time drain.

\sphinxAtStartPar
There are many different types of static code analysis.

\sphinxAtStartPar
\sphinxstyleemphasis{Linting} is essentially a spell\sphinxhyphen{}check of your code. The example below shows Rust program code. It has detected that the variable \sphinxcode{\sphinxupquote{%
\PYG{n}{j}%
}} (and indeed \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} in this simple example) is never used. It’s checking that this is what you want, because it might indicate a mistake. Moreover, it suggests using the preferred (but optional) style of using \sphinxcode{\sphinxupquote{%
\PYG{n}{\PYGZus{}j}%
}} to indicate it’s deliberately not used for some reason. Indeed for a simple error like this offers a \sphinxstyleemphasis{Quick Fix} to automatically correct it for you.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{linting}.png}
\end{figure}

\sphinxAtStartPar
Linting is probably the most common form of static code analysis that you’ll encounter. If desired, there are many other checks you can perform via static code analysis. For example, you can get analyzers that compare your code against a given style guide, or analyzers that examine the code for known security risks. We would encourage you to explore the VSCode interface, documentation, and online help to explore what other types of analysis might be useful.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ve set up the development tools to do linting automatically. We won’t cover other forms of static code analysis.
\end{sphinxadmonition}

\sphinxstepscope


\section{Debugger}
\label{\detokenize{chapters/software_development_tools/debugger:debugger}}\label{\detokenize{chapters/software_development_tools/debugger:id1}}\label{\detokenize{chapters/software_development_tools/debugger::doc}}
\sphinxAtStartPar
The debugger is for analyzing your code, while it is running. It puts the code into a special state which lets you look at (say) the value of a variable. This makes the code slower to execute, as everything needs to be logged, but is very useful for examining what’s going on when things aren’t working as expected. Most debuggers then let you then step through the code, say line\sphinxhyphen{}by\sphinxhyphen{}line, to let you pin\sphinxhyphen{}point errors and, hopefully, fix them. An example in Rust is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{debugger}.png}
\end{figure}

\sphinxAtStartPar
Here, a \sphinxstyleemphasis{break point} has been added, by clicking next to the line number. When compiled and run, the program executes up to the break point, and then pauses. Debug information is then displayed and can be used to help you fix the program. For example, you can change the value of a variable by hand, and then continue the execution to see what happens.

\sphinxAtStartPar
In the example above, the error is probably a typo. Line 4 should probably be \sphinxcode{\sphinxupquote{%
\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}%
}} rather than \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}%
}}. Static code analysis struggles to spot this, as \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}%
}} is perfectly valid code, just probably not what’s wanted in this case. (Also \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} is used later on in the code, so static analysis can’t detect that it’s not being used.)

\sphinxAtStartPar
It’s worth spending some time exploring the debugger as it’s an incredibly powerful tool for identifying and fixing issues with your code. For example, you can add conditional break points, which will only trigger the program to pause execution if certain conditions are met.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ll use debugging in VSCode a lot throughout the course and you’ll be expected to be familiar with how to use this.

\sphinxAtStartPar
Note that debuggers show the limitations of VSCode as an IDE. For example, the GUI buttons in VSCode will only let you step forwards through the code, to see what happens next. Some debuggers will let you do \sphinxstyleemphasis{reverse debugging}, where you can step backwards through the code to see how it got into a particular state. In VSCode you have to run this from the command line, there’s no GUI button for it. We thus won’t look in to it, but do remember there are lots of tools available to help you above and beyond the ones we do cover. Don’t limit your thinking or reading to only the ones considered here.
\end{sphinxadmonition}

\sphinxstepscope


\section{Profiler and computational complexity}
\label{\detokenize{chapters/software_development_tools/profiler:profiler-and-computational-complexity}}\label{\detokenize{chapters/software_development_tools/profiler::doc}}

\subsection{Profiler}
\label{\detokenize{chapters/software_development_tools/profiler:profiler}}
\sphinxAtStartPar
When we looked briefly at {\hyperref[\detokenize{chapters/computer_hardware:computer-hardware}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{computer architecture}}}}}, we noted that there were a number of potential bottlenecks present which may limit how quickly any code can run. It may be that the code is limited by the processor, or by the amount of memory that is present, or by the input/output bandwidth.

\sphinxAtStartPar
For all code, it’s useful to know which resources are being used the most. This allows you to potentially change your code to make it faster, or use fewer resources, or to compare how many resources two different approaches require. For performance critical applications this is very important.

\sphinxAtStartPar
A \sphinxstyleemphasis{profiler} analyses your code to generate a report on resource usage that you can use to inform the design or optimization of your code.

\sphinxAtStartPar
For example, in Python you might use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{cProfile}
\PYG{n}{cProfile}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}Python code here\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
More generally, you might install a profiler outside of the IDE environment and use it as an independent tool. \sphinxcode{\sphinxupquote{%
\PYG{g+go}{perf}%
}} is a common tool if using Linux. Intel make a free profiler available called \sphinxhref{https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html}{VTune}  which runs on Windows, macOS, and Linux.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’re not going to make use of profilers, but you might like to remember they’re a tool you can investigate and make use of if you find your code takes too long to run or is too resource intensive.
\end{sphinxadmonition}


\subsection{Computational complexity}
\label{\detokenize{chapters/software_development_tools/profiler:computational-complexity}}
\sphinxAtStartPar
In addition to analyzing the code you actually have, it’s common to think \sphinxstyleemphasis{conceptually} about what the computational complexity is. We won’t focus too much on this, but it is often useful to think about how well an algorithm, or code implementing that algorithm, will scale as more data is passed to it.

\sphinxAtStartPar
In {\hyperref[\detokenize{chapters/software_development_tools/pseudocode:pseudocode}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pseudocode}}}}}, if you have an algorithm:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{each} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{elements}
    \PYG{n}{count} \PYG{o}{=} \PYG{n}{count} \PYG{o}{+} \PYG{n}{value\PYGZus{}of\PYGZus{}current\PYGZus{}element}
\end{sphinxVerbatim}

\sphinxAtStartPar
this will scale linearly. If there were 10 values in the elements array, rather than the current 5, we’d expect it to take twice as long to execute. This is because the addition will take the same amount of time in every case, so the complexity is dominated by how many times the for loop has to run. If we double the number of values present, we double the number of times the loop executes. Doubling the size of the input, doubles the execution time, and so the complexity is scaling linearly with the input size.

\sphinxAtStartPar
Typically we use \sphinxstyleemphasis{Big O} notation to represent complexity. If \(n\) is the number of values present in the elements array, the above example would be \(O(n)\).

\sphinxAtStartPar
Different code could be \(O(n^2)\). Here, doubling the elements from 5 to 10 would result in code which takes 4 times as long to run \((10^2/5^2)\). Code which is \(O(n^3)\) or even \(O(n!)\) is possible, and may take a long time to run when you have lots of data! With some thought, lots of algorithms can be written to be \(O(n \log n)\), but this might require some effort and not be the first approach you come up with.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
In terms of this course, computational complexity is a relatively advanced topic. It’s more something to be aware of than something we’ll use lots. It affects the design stage of code, possibly more than the implementation stage where you can use the profiler. If your code is going to take a long time to run, at the design stage you need to consider both the software architecture, and the potential computational complexity of the approach. Even if it’s just a rough estimate, it can help you discount some potential approaches early on. We won’t look at this in depth though.
\end{sphinxadmonition}

\sphinxstepscope


\section{Version control}
\label{\detokenize{chapters/software_development_tools/version_control:version-control}}\label{\detokenize{chapters/software_development_tools/version_control:id1}}\label{\detokenize{chapters/software_development_tools/version_control::doc}}
\sphinxAtStartPar
It’s very common to have more than one version of a piece of software or set of files. Generally, more features are added over time, or bugs are fixed. Often when writing a program, you may make one part of the code work and then move on to the next part. When working on this next part, you don’t want to break the things that already work! This is known as \sphinxstyleemphasis{regression}. It means you have to spend time correcting things that once worked, and you’ve (presumably) accidentally broken.

\sphinxAtStartPar
To avoid this, whenever we have a working piece of code, we usually \sphinxstyleemphasis{commit} it to a version control system. The version control system keeps track of the different versions of each file and it’s easy to roll\sphinxhyphen{}back to a previous version if you have to, or to get a display of what has changed between different versions. Generally, we use the version control system to keep track of different versions of the same file, we don’t make a copy ourselves and call it (say) \sphinxcode{\sphinxupquote{%
\PYG{g+go}{my\PYGZus{}work\PYGZhy{}backup.py}%
}}.

\sphinxAtStartPar
Version control is also widely used when working in teams. Multiple people can be working on the code in one repository at the same time, and use the version control system to keep the code in sync with one another and to pass code between one another.

\sphinxAtStartPar
There are a wide number of version control tools that can be used. Historically, CVS, and then subversion, were very popular. Today, git is widely used. Git is a separate tool to install, but the VSCode GUI then provides an interface to it. Alternatively, you can use git at the command line.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{version_control}.png}
\end{figure}

\sphinxAtStartPar
We’ll see git in the labs. To briefly introduce it, the usage model is shown below. The core flow is shown in green. More optional, and more advanced, functions are shown in orange. The terminology used is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Remote repository}. This is the shared space where multiple people can place and view the code. The code might be available publicly, or only available to people who are given permission. We typically use \sphinxhref{https://github.com/}{GitHub}, although \sphinxhref{https://about.gitlab.com/}{GitLab} is also popular, and indeed the remote repository can be essentially anywhere. You can view my work repositories \sphinxhref{https://github.com/Non-Invasive-Bioelectronics-Lab}{here}, and the files for this course at \sphinxhref{https://github.com/UOM-EEE-EEEN1XXX2}{the main repository}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Clone}. Cloning is the process of making a local copy, on your computer, of a remote repository. You can clone a blank repository, or one which already has a number of files in it. Often the first step when using git is to either clone an existing repository, or to make a blank repository on \sphinxhref{https://github.com/}{GitHub} (say) and then to clone this.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Local repository}. This is your copy of the code files, stored on your computer. These are the files that you edit and do your development with.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Commit}. When you have files that are working, or some version that you want to log, you commit these to the local repository. This marks the versions that you want to keep a copy of. Sometimes this is also known as \sphinxstyleemphasis{checking\sphinxhyphen{}in} the code.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Staging}. Before committing files, you have to tell git which files you want to commit. This is known as staging the changes. For simple projects, you probably just want to stage and commit all of the files. For more complex projects, there may be files which are specific to one computer and so don’t want to be sent to a remote repository. There may be secrets such as security keys which shouldn’t be shared. Staging and the \sphinxcode{\sphinxupquote{%
\PYG{g+go}{.gitignore}%
}} file allow control of what gets logged.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Push}. When you want to, you push your files to the remote repository (assuming you have permissions to do this). This will update the code that others can see. Until you do a push, only your local files will have been updated with any changes. You can do a push after every commit, or just every\sphinxhyphen{}so\sphinxhyphen{}often, whatever is best for you. You might get a \sphinxstyleemphasis{conflict}, say if two people have been working on the exact same piece of code at the same time. You’ll be asked to resolve this before the push can complete.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Pull}. A pull will update your repository with the latest version from a different repository. This will let you get updates from others.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Fork}. A fork is making a copy of existing code, so that you can work on it separately. This is typically done when you’re starting a new project, but want to start from an existing one. So, you’re not modifying the existing project, you’re modifying your copy, or fork, of it.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Branch}. Sometimes you want or need more than one copy of some files in your repository. Maybe you’re actively working on Version 2, but it’s not ready yet and so Version 1 needs to be present too. You can make a branch for developing Version 2 in. This keeps it separate from the other code, with the ability to merge it in later.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Reset} or \sphinxstyleemphasis{Revert}. You can switch between different committed versions of the code, if you want to roll\sphinxhyphen{}back to a previous version, or if you want to compare the changes that have been made.

\end{itemize}

\sphinxAtStartPar
This workflow is summarized in the figure below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{git_workflow}.png}
\end{figure}

\sphinxAtStartPar
Overall, having both local and remote repositories is very powerful for team working. It allows you to work on your copy of the code, keeping it in version control so you can track any changes and/or roll\sphinxhyphen{}back if you need to. When ready, you can then synchronize the local and the remote repository. This updates your code with any updates from others, but only when you’re ready and do a \sphinxstyleemphasis{pull}. Equally, your local changes are only sent out to others when you’re ready and do a \sphinxstyleemphasis{push}.

\sphinxAtStartPar
There are git commands with all of the different terms introduced above. You can run git at the command line to get full control of the options present. For example, to clone a remote repository and get a copy on your computer (assuming this is where you want to put it):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} cd P:\PYGZbs{}Desktop\PYGZbs{}my\PYGZus{}copy}
\PYG{g+go}{\PYGZgt{} git clone https://github.com/ALEX\PYGZhy{}CASSON\PYGZhy{}LAB/uom\PYGZus{}msc\PYGZus{}dissertation\PYGZus{}word\PYGZus{}template}
\end{sphinxVerbatim}

\sphinxAtStartPar
To commit changes you’ve made to the files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} git commit \PYGZhy{}m \PYGZdq{}Brief description of what\PYGZsq{}s changed\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} git \PYGZhy{}\PYGZhy{}help}
\end{sphinxVerbatim}

\sphinxAtStartPar
to see a full list of the available commands.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
Knowledge of version control is a learning outcome from the course. We’ll use git extensively in the labs and expect you to be familiar with it.
\end{sphinxadmonition}

\sphinxstepscope


\section{Environment control}
\label{\detokenize{chapters/software_development_tools/environment_control:environment-control}}\label{\detokenize{chapters/software_development_tools/environment_control::doc}}
\sphinxAtStartPar
Version control is for keeping track of the code and documentation files that we make, letting us roll back to previous versions or see changes from previous versions.

\sphinxAtStartPar
Often there might be a wide range of other files or information that are needed to make your code work, beyond the main code files themselves. In particular, there is the \sphinxstyleemphasis{version} of the programming language and tools (IDE, operating system, etc.) that you use.

\sphinxAtStartPar
Python has lots of different versions (e.g. 3.7, 3.10, 3.13), changing as new features are added. A new version is released each year, which then has active support for 2 years, and security support for 5 years. Rust is released in \sphinxstyleemphasis{editions} every 3 years and also has versions released more frequently. We’ll also find it’s common to load external code as part of a Python or Rust program. Each one of these \sphinxstyleemphasis{modules} or \sphinxstyleemphasis{libraries} will also have a version, which changes over time.

\sphinxAtStartPar
Environment control helps us lock the development environment, ensuring that you’re using a fixed, known set of versions for everything. If there are multiple people all working on the same project, environment control also helps ensure everyone is using the same versions.

\sphinxAtStartPar
Environment control software gives us tools for keeping track of which versions of the different tools and libraries are installed, and potentially to have multiple versions of these installed at the same time so we can move to different versions as required. They make a \sphinxstyleemphasis{container}, or a \sphinxstyleemphasis{virtual environment}, or possibly a complete virtual computer (a virtual machine) inside your real computer. You can have multiple containers running at the same time, each with different development environments installed in them.

\sphinxAtStartPar
There are several parts to environment control:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
There is a \sphinxstyleemphasis{container} which defines the operating system to be used and the programs it should have installed. \sphinxhref{https://www.docker.com/}{Docker},  \sphinxhref{https://podman.io/}{Podman} and \sphinxhref{https://kubernetes.io/}{kubernetes} are popular choices. (Generally Docker is the starting point, and kubernetes is for larger cloud based projects.) The user of the container may or may not be allowed to install additional programs.

\item {} 
\sphinxAtStartPar
There is a \sphinxstyleemphasis{devcontainer} which configures the development environment, VSCode in our case, to have the settings we want. For VSCode, this is mainly installing the extensions needed for the different programming languages to be used.

\item {} 
\sphinxAtStartPar
(Python only.) There is a \sphinxstyleemphasis{virtual environment} which defines the specific version of Python and the various modules being used. You may have multiple virtual environments if you have code that needs different versions of Python to run. Typically we have one virtual environment per \sphinxstyleemphasis{project}, and it’s up to the user to define how big or small each project is. Generally it’s bad practice to just have one global virtual environment for all of your work. You’ll probably quickly find you have conflicts in which versions of modules are needed in order for different parts of the code to work.

\item {} 
\sphinxAtStartPar
There is a \sphinxstyleemphasis{configuration file} setting up the project, listing its \sphinxstyleemphasis{dependencies}. That is, what version of the programming language is being used; and whether there are any external modules that are being used to add functionality, and if so whether there are any constraints on which versions can be used. In Python, there are a number of options, but these would generally be listed in a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{pyproject.toml}%
}} file (or a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{requirements.txt}%
}} file in older projects). In Rust, the configuration is kept in a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{Cargo.toml}%
}} file.

\end{enumerate}

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We don’t expect you to know about containers and devcontainers. We have made these for you (because we want everyone to be using the same versions of the different tools needed!). You just need to follow the instructions given in the lab notes. Once you have a programming environment setup, you probably won’t need to refer to these pages again. If you’re interested, our \sphinxstyleemphasis{dockerfile} which defines the EEEN11202 container is in our \sphinxhref{https://github.com/UOM-EEE-EEEN1XXX2/dockerfile}{GitHub repository}, as is our \sphinxhref{https://github.com/UOM-EEE-EEEN1XXX2/devcontainer}{devcontainer file}.

\sphinxAtStartPar
For Python, we do expect you to know about, and be able to use, virtual environments. They are an essential part of knowing Python, and we’ll use them throughout the labs.

\sphinxAtStartPar
We’ll also make use of \sphinxcode{\sphinxupquote{%
\PYG{g+go}{pyproject.toml}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{g+go}{Cargo.toml}%
}} files where appropriate. We’d expect you to have some knowledge of these, only to the extent that we use them in the labs.
\end{sphinxadmonition}

\sphinxstepscope


\section{Unit and integration testing}
\label{\detokenize{chapters/software_development_tools/automated_testing:unit-and-integration-testing}}\label{\detokenize{chapters/software_development_tools/automated_testing:automated-testing}}\label{\detokenize{chapters/software_development_tools/automated_testing::doc}}

\subsection{General principles}
\label{\detokenize{chapters/software_development_tools/automated_testing:general-principles}}
\sphinxAtStartPar
Debugging is one aspect of testing, generally focused on making your code fundamentally run. Testing in general, is a much wider topic. You need to thoroughly test your code, running it multiple times, to check that it behaves in the way that you want it to. Whenever possible, we don’t wait around for users to tell us about bugs in our program. Instead we write automated tests that can tell us if anything is broken.

\sphinxAtStartPar
For example, your code may accept a wide range of inputs, or have a range of different options. It’s not uncommon for code to work in a large number of cases, but fail in some \sphinxstyleemphasis{corner cases}. Maybe you weren’t expecting a filename which includes a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{!}%
}}. Your code may work fine, except for cases when an exclamation mark \sphinxcode{\sphinxupquote{%
\PYG{g+go}{!}%
}} is present in a filename passed to it.

\sphinxAtStartPar
It’s hard to test every possible input, but you probably want to make a \sphinxstyleemphasis{test suite}, which automatically passes a wide range of filenames (in this example) to your code to check that it works.

\sphinxAtStartPar
Thus, for non\sphinxhyphen{}trivial code, you often have to actually write two different parts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The actual code of your project that implements your wanted functionality.

\item {} 
\sphinxAtStartPar
A \sphinxstyleemphasis{test wrapper} (or \sphinxstyleemphasis{test harness}) which can run your code and check that, for various cases that are important to you, the code actually does what you want.

\end{itemize}

\sphinxAtStartPar
Note that these different parts don’t necessarily have to be in the same language. Also, you may need to make a test suite, to test the test wrapper!

\sphinxAtStartPar
Within this, testing is usually broken down into two stages: \sphinxstyleemphasis{unit testing} and \sphinxstyleemphasis{integration testing}.


\subsection{Unit tests}
\label{\detokenize{chapters/software_development_tools/automated_testing:unit-tests}}\label{\detokenize{chapters/software_development_tools/automated_testing:unit-testing}}
\sphinxAtStartPar
We noted previously that software projects in practice can be thousands or {\hyperref[\detokenize{chapters/computer_software/files_and_folders:files-folders-filesystems}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{millions of lines of code long}}}}}. Testing all of this in one go is hard! We need to break it down into smaller pieces, to help compartmentalize where any issues might lie.

\sphinxAtStartPar
To do this, we try and write blocks of code in as small chunks, known as \sphinxstyleemphasis{units}, as possible. We then connect these units together to make a bigger program. Each unit is less code than a big complex function, and easier to test and debug in isolation.

\sphinxAtStartPar
\sphinxstyleemphasis{Unit testing} refers to testing each of the individual blocks in isolation. The idea is that if each block works, then any issues later can only be due to the interaction of different blocks. It thus helps localize where any issues might be, so you know where to look when investigating them.

\sphinxAtStartPar
There’s no hard rule for what or how big a unit is. A decision needs to be made during the {\hyperref[\detokenize{chapters/software_lifecycle/software_architecture:software-architecture}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{software architecture stage}}}}} for what would be suitable sub\sphinxhyphen{}blocks to split the design and testing into.


\subsection{Integration tests}
\label{\detokenize{chapters/software_development_tools/automated_testing:integration-tests}}\label{\detokenize{chapters/software_development_tools/automated_testing:integration-testing}}
\sphinxAtStartPar
\sphinxstyleemphasis{Integration testing} comes when you connect all of your different blocks together to check that the larger function works as expected. Generally, you have a list or database of different inputs to provide, or tests to run, where you know what the output should be, so you can check whether it’s working.

\sphinxAtStartPar
In random testing you generate a set of test inputs randomly. In directed testing you enter explicit test inputs that are important to you to check.

\sphinxAtStartPar
To help with the above, there are \sphinxstyleemphasis{testing frameworks} such as \sphinxhref{https://docs.pytest.org/en/stable/}{pytest} to help run the above processes. We’ll see some of these in the labs.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We will spend some time in the labs looking at unit testing in both Python and Rust.
\end{sphinxadmonition}

\sphinxstepscope


\section{Continuous integration}
\label{\detokenize{chapters/software_development_tools/continuous_integration:continuous-integration}}\label{\detokenize{chapters/software_development_tools/continuous_integration::doc}}
\sphinxAtStartPar
Continuous integration comes when we combine our {\hyperref[\detokenize{chapters/software_development_tools/version_control:version-control}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{version control system}}}}} with {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:automated-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{automated testing approaches}}}}}.

\sphinxAtStartPar
You can configure tools to automatically run your test harness whenever you commit your code. It will thus automatically give you a list of what’s not working so you know where attention is still required.

\sphinxAtStartPar
You can go so far as having Git reject any commits which don’t pass the tests present. This will ensure that you always have code that works in your repository, and you can’t ship code with known issues unless you override this. (Although this might get in the way of good version control of minor changes.)

\sphinxAtStartPar
Common tools include \sphinxhref{https://github.com/features/actions}{GitHub Actions} and \sphinxhref{https://www.jenkins.io/}{Jenkins}, but there are many others.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We won’t make use of continuous integration in this course. You don’t need to know anything more than what’s in these brief notes, unless you want to go further for your own purposes.

\sphinxAtStartPar
We don’t make use of fully continuous integration when making the course materials, but if interested you can view the \sphinxhref{https://github.com/UOM-EEE-EEEN1XXX2/notes-part1/tree/main/.github}{GitHub Actions for these notes}. GitHub Actions automatically update the dependencies for us, and re\sphinxhyphen{}build the lecture notes and automatically update the website each time a new version is checked into the Git remote repository.
\end{sphinxadmonition}

\sphinxstepscope


\section{Formatters}
\label{\detokenize{chapters/software_development_tools/formatters:formatters}}\label{\detokenize{chapters/software_development_tools/formatters::doc}}
\sphinxAtStartPar
We mentioned \sphinxhref{https://uom-eee-eeen1xxx2.github.io/chapters/useful\_information/style\_guide.html}{style guides previously}. There are lots of choices for how we layout code. For example, do we use AAAA or aaaa as a variable name? These choices don’t necessarily affect what the code does, but when working as part of a team if everyone’s code is formatted the same way, it makes it easier to share code and to read code written by others.

\sphinxAtStartPar
To help with this, there are automatic formatting tools, such as \sphinxhref{https://docs.astral.sh/ruff/}{Ruff} for Python, and \sphinxhref{https://github.com/rust-lang/rustfmt}{rustfmt}  for Rust. These will re\sphinxhyphen{}layout your code automatically to try and keep it correctly on a specified style.

\sphinxAtStartPar
For example, in Python it might convert single quotes \sphinxcode{\sphinxupquote{%
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}%
}} into double quotes \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}%
}}. In many places in Python, both styles of quote work in exactly the same way, but a style guide will say that one of the ways is preferred. (Probably double quotes.)

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
You don’t need to learn anything about formatters. In the EEEN11202 devcontainer, we have turned on \sphinxstyleemphasis{format on save} automatically for Python and Rust files. This means that each time you save your code file the auto\sphinxhyphen{}formatter will automatically be applied to your work. It may change some of your code to put it onto the correct style.
\end{sphinxadmonition}

\sphinxstepscope


\section{Code reviews}
\label{\detokenize{chapters/software_development_tools/code_reviews:code-reviews}}\label{\detokenize{chapters/software_development_tools/code_reviews::doc}}
\sphinxAtStartPar
The previous testing techniques have focused on automated approaches, and on running the code to see what happens. In addition, you can just have another human read your code and give feedback on it! Code reviews are widely used, getting a peer or a manager to look at code in order to improve its quality. AI code reviews are also increasingly common. Rather than using AI to generate code for you, you still write the code but ask AI for feedback  on it.

\sphinxAtStartPar
Say I gave you some Python code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{math}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{G} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{n}{G} \PYG{o}{=} \PYG{l+m+mi}{7}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{h} \PYG{o}{+} \PYG{l+m+mi}{7}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{f} \PYG{o}{+} \PYG{l+m+mi}{7}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
What would your feedback on it be?

\sphinxAtStartPar
Some options that you might say are below. (You’ve not seen all of these topics in the course yet, so you might also like to re\sphinxhyphen{}visit this when you’re a little further on.)
\begin{itemize}
\item {} 
\sphinxAtStartPar
There are no comments in the code. It’s not at all clear what it’s meant to be doing.

\item {} 
\sphinxAtStartPar
Using upper case G is perfectly fine code, but it’s not in\sphinxhyphen{}line with our style guide that we’re following to keep our code consistent.

\item {} 
\sphinxAtStartPar
It imports the math module, allowing more maths functions to be used in the code, but none of these are used. You don’t need to \sphinxcode{\sphinxupquote{%
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{math}%
}} just for an addition. If you’re not using the functionality, you shouldn’t import the module.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{%
\PYG{o}{+}\PYG{l+m+mi}{7}%
}} appears multiple times. The \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{7}%
}} is thus \sphinxstyleemphasis{hard coded}. Would this be better as a variable, so if it changes, it changes everywhere? Indeed, \sphinxcode{\sphinxupquote{%
\PYG{n}{G}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{7}%
}}. Should these lines really be \sphinxcode{\sphinxupquote{%
\PYG{o}{+}\PYG{n}{G}%
}}?

\end{itemize}

\sphinxAtStartPar
This is a simple example, but there’s lots of power in getting peer review and feedback on your code.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
You can put up your hand in any of the lab sessions to get a graduate teaching assistant to review your code.
\end{sphinxadmonition}

\sphinxstepscope


\section{Buddy programming}
\label{\detokenize{chapters/software_development_tools/buddy_programming:buddy-programming}}\label{\detokenize{chapters/software_development_tools/buddy_programming::doc}}
\sphinxAtStartPar
A step on from code reviews, where someone else looks at your code after you’ve written it, is to sit together with another person and write the code together. This means that you can discuss non\sphinxhyphen{}trivial aspects as you’re writing the code. Any choices are discussed there and then, rather than waiting for a review later. This style of coding requires more resources (i.e. two people), but this may be beneficial overall if the code has fewer issues that need lots of debugging.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
This is designed as an individual course. We expect most people to discuss their work with their classmates, but there are no \sphinxstyleemphasis{buddy} tasks or similar. Remember, all submitted works must be your own individual work.
\end{sphinxadmonition}

\sphinxstepscope


\section{Modules, libraries, and similar}
\label{\detokenize{chapters/software_development_tools/libraries:modules-libraries-and-similar}}\label{\detokenize{chapters/software_development_tools/libraries:libraries}}\label{\detokenize{chapters/software_development_tools/libraries::doc}}
\sphinxAtStartPar
You don’t necessarily have to write all of your code yourself! There is lots of code that has already been written. Lots of it is freely available on the Internet for others to use, for example on sites like \sphinxhref{https://github.com/}{GitHub}.

\sphinxAtStartPar
There’s also code, generally known as \sphinxstyleemphasis{modules} or \sphinxstyleemphasis{libraries} or \sphinxstyleemphasis{packages} which extend what the base programming language can do. Using these is very common. (We’ll generally use the terms modules, libraries, and packages inter\sphinxhyphen{}changeably, even if technically they’ll all slightly different things.)

\sphinxAtStartPar
There are three broad categories of external code that you might add in to your code.


\subsection{Standard library}
\label{\detokenize{chapters/software_development_tools/libraries:standard-library}}\label{\detokenize{chapters/software_development_tools/libraries:id1}}
\sphinxAtStartPar
Most programming languages only have a very limited number of commands enabled by default. This helps keep the resulting programs small and limits the potential attack vector for security bugs and similar.

\sphinxAtStartPar
The \sphinxstyleemphasis{standard library} is installed automatically, whenever you set up your programming tools/environment, and so it always available for your code to use. To use functions in the standard library you need need to add \sphinxcode{\sphinxupquote{%
\PYG{k+kn}{import}%
}} or \sphinxcode{\sphinxupquote{%
\PYG{k}{use}%
}}, or similar, the parts that you want. That is, you have to explicitly say which parts you want to use.

\sphinxAtStartPar
For example, in Python you might add

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{math}
\end{sphinxVerbatim}

\sphinxAtStartPar
to add maths functions to the code. In Rust you might add

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{use} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{io}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to add functions for reading input from the command line, and displaying output back to the terminal.

\sphinxAtStartPar
There are lots of functions available in the standard library. We won’t cover them all here, but you will encounter lots as you move through the course.


\subsection{Packages from online repositories}
\label{\detokenize{chapters/software_development_tools/libraries:packages-from-online-repositories}}
\sphinxAtStartPar
There are many libraries available on the Internet to extend the functionality of the base programming language. These are stored in \sphinxstyleemphasis{repositories}.

\sphinxAtStartPar
For Python, \sphinxhref{https://pypi.org/}{PyPi} is a common repository for packages. Indeed it is likely the default one used unless you change your Python configuration. At the command line there is a Python tool called \sphinxcode{\sphinxupquote{%
\PYG{g+go}{pip}%
}} which you can use to install additional modules from the Internet. You add these to your code with an \sphinxcode{\sphinxupquote{%
\PYG{k+kn}{import}%
}} command. We’ll see examples of doing this in the labs.

\sphinxAtStartPar
For Rust, \sphinxhref{https://crates.io/}{crates.io} will be the default repository for packages. In Rust, you list \sphinxcode{\sphinxupquote{%
\PYG{p}{[}\PYG{n}{dependencies}\PYG{p}{]}%
}} in the \sphinxcode{\sphinxupquote{%
\PYG{g+go}{Cargo.toml}%
}} project configuration file and add these to your code with the \sphinxcode{\sphinxupquote{%
\PYG{k}{use}%
}} command. Again, we’ll see examples of doing this in the labs.

\sphinxAtStartPar
For C/C++, \sphinxhref{https://vcpkg.io/en/}{vcpkg} is commonly used.


\subsection{Code from online sites such as GitHub}
\label{\detokenize{chapters/software_development_tools/libraries:code-from-online-sites-such-as-github}}
\sphinxAtStartPar
The packages above have been \sphinxstyleemphasis{pre\sphinxhyphen{}packaged}. You download them and add them to your code, without necessarily ever seeing the actual code that you’re downloading. There are tools, such as \sphinxcode{\sphinxupquote{%
\PYG{g+go}{pip}%
}} to make working with packages easier.

\sphinxAtStartPar
In contrast, sites such as \sphinxhref{https://github.com/}{GitHub} share raw source code. How to interact with this is up to you. You may copy\sphinxhyphen{}and\sphinxhyphen{}paste just some small sections of the code which are relevant to what you want; or you may download the whole project and add it to your own. Using code from a source like \sphinxhref{https://github.com/}{GitHub} is useful if you want/need to be able to see how the code works, rather than just using the functionality a package provides in an \sphinxstyleemphasis{opaque box} manner.


\subsection{Important considerations}
\label{\detokenize{chapters/software_development_tools/libraries:important-considerations}}\label{\detokenize{chapters/software_development_tools/libraries:code-security}}
\begin{sphinxadmonition}{danger}{Danger:}
\sphinxAtStartPar
When downloading code from others/the Internet, make sure you think about cybersecurity before doing so. If you let code run on your computer, it may have access to your files, to leak information to others, or to take various other malicious actions.

\sphinxAtStartPar
In general, we would trust items in the standard library without too much further consideration. For external packages, there are very commonly used ones, such as numpy and matplotlib, and again we would likely trust these without too much further consideration. For more obscure packages, it may be that more thought is warranted.

\sphinxAtStartPar
Most companies will probably restrict which external packages you can install to a pre\sphinxhyphen{}defined set which have been through some form of a security audit.
\end{sphinxadmonition}

\begin{sphinxadmonition}{caution}{Caution:}
\sphinxAtStartPar
Just because code or pre\sphinxhyphen{}defined packages are openly available on the Internet doesn’t necessarily mean that they give you the correct permissions to use them in your project. We will discuss {\hyperref[\detokenize{chapters/software_development_tools/licensing:software-licenses}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{software licenses}}}}} in more detail later. Briefly, code usually comes with a set of terms and conditions giving constraints on how it can be used. Potentially, these terms could be incompatible with the needs of your project, and may limit what can be used.

\sphinxAtStartPar
Before using external code, make sure you check how it is licensed and what constraints or obligations the license places on the user.

\sphinxAtStartPar
All also of course need to check that any external code actually works! It’s possible it contains bugs and won’t work perfectly when you try to use it.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ll use external packages a lot throughout the course, and having knowledge of some common packages (e.g. Numpy, Scipy, Pandas/Polars, Matplotlib) is a topic we’ll cover.

\sphinxAtStartPar
In the development environment we’ve not added any constraints on what packages can be installed, so that you can explore. Be aware that you might not have access to any arbitrary package in the exam or in your more general programming practice however.
\end{sphinxadmonition}

\sphinxstepscope


\section{Software licenses}
\label{\detokenize{chapters/software_development_tools/licensing:software-licenses}}\label{\detokenize{chapters/software_development_tools/licensing:id1}}\label{\detokenize{chapters/software_development_tools/licensing::doc}}
\sphinxAtStartPar
In programming, there is a strong tradition of \sphinxstyleemphasis{open source} outputs. Sometimes companies want to keep their code private, or proprietary, so that others can’t copy what they’ve done. Other times, volunteers will freely offer to contribute code to a project to add features that are important to them. If the code is open source, they can do this.

\sphinxAtStartPar
Moreover, for some code, being open source means that many people can look at it, and help identify bugs or security vulnerabilities. Also, people often like to share their code so that others can re\sphinxhyphen{}use it to help them meet their objectives more quickly. This may be altruistic, making a contribution to the community to help others.

\sphinxAtStartPar
Just because your code is open source doesn’t mean that you can’t make money from it. Many companies fundamentally work on open source code, and then charge for providing support to users.

\sphinxAtStartPar
If writing open source code, the worst thing you can do is \sphinxstyleemphasis{just stick it on the Internet}. This doesn’t give any potential users information on what they need to do to use the code legitimately. What is the author of the code responsible for, vs. the person that uses it in their project? What acknowledgement or recognition needs to be given to the original author? All open code should be accompanied by a \sphinxstyleemphasis{license}, which says what the code can and can’t be used for, and any restrictions or requirements for its use.

\sphinxAtStartPar
If you set up a new repository at (say) \sphinxhref{https://github.com/}{GitHub}, it will ask you what license you want to attach to the code. There are many different licenses you might choose between. Briefly, some major ones:
\begin{itemize}
\item {} 
\sphinxAtStartPar
MIT license. This is a very permissive license. It basically says you can do what you like with the code, but the original author isn’t involved. They hope it’s useful, but otherwise it’s up to you to make it work. You have to include a copyright statement saying who wrote the code.

\item {} 
\sphinxAtStartPar
BSD license (3 clause). Is also very permissive, but says you can’t advertise the name of the original author as an endorsement of your software.

\item {} 
\sphinxAtStartPar
GPL license (version 2 or version 3). Aims to avoid restrictions being placed on software. If you use or modify GPL code, that code will have the same GPL requirements. Thus, if you use GPL licensed code in your project, and you update that code, you are asked to provide the updated code to users. You can sell GPL code, but you then can’t limit a user’s right to modify or distribute the code.

\item {} 
\sphinxAtStartPar
CC\sphinxhyphen{}BY. The above are licenses for code. For text and documents, CC\sphinxhyphen{}BY is a commonly used license. There are a number of variants, generally asking you to give attribution to the original author, and to indicate what changes have been made.

\end{itemize}

\sphinxAtStartPar
Sites such as \sphinxhref{https://choosealicense.com/appendix/}{choosealicense} and \sphinxhref{https://creativecommons.org/share-your-work/cclicenses/}{creative commons} have tools to help you pick a license.

\sphinxAtStartPar
Depending on the needs of your project or company, the different licenses may mean you can’t use some code in your project, even if fundamentally it’s publicly available for people to use. You should read the license, and what it lets you do, before using code in a project.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
Your code, even on \sphinxhref{https://github.com/}{GitHub}, will be private, and so we won’t ask you to add a license. You thus don’t need to have any more familiarity than the contents of these notes. After the course, if you start your own programming projects and sharing your code publicly online, you should think about which license to add.

\sphinxAtStartPar
For the course notes, we use a range of different licenses (after getting permission from the University of Manchester for the core course to be open source). If you click on the GitHub (\sphinxincludegraphics[width=20\sphinxpxdimen]{{GitHub_Invertocat_Dark1}.svg}) icon to view the source for the notes, the GitHub site will contain information on the license(s). Usually our code is under an MIT license, and text under a CC\sphinxhyphen{}BY license. Where items have been used from others (such as the fonts), a number of different licenses are present.
\end{sphinxadmonition}

\sphinxstepscope


\section{Pseudocode}
\label{\detokenize{chapters/software_development_tools/pseudocode:pseudocode}}\label{\detokenize{chapters/software_development_tools/pseudocode:id1}}\label{\detokenize{chapters/software_development_tools/pseudocode::doc}}
\sphinxAtStartPar
The tools mentioned so far are software programs that help you write correct code. There are also tools and techniques that will help you plan and design your code. The main one to mention here is \sphinxstyleemphasis{pseudocode}. This isn’t a software tool, it’s an approach to planning your code before you write it in detail.

\sphinxAtStartPar
Pseudocode is a detailed, but readable, description of what you want your program to do. A very high level example might be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Decide to take train}
\PYG{g+go}{Pick which train to get}
\PYG{g+go}{Buy ticket}
\PYG{g+go}{Get tram to Manchester Piccadilly station}
\PYG{g+go}{Get on train}
\end{sphinxVerbatim}

\sphinxAtStartPar
This a long way from actual code that gets a robot to take a train(!), but is a start towards some of the key functional blocks that are going to be needed.

\sphinxAtStartPar
As a lower level example, when considering the profiler we had:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{elements} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{each} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{elements}
    \PYG{n}{count} \PYG{o}{=} \PYG{n}{count} \PYG{o}{+} \PYG{n}{value\PYGZus{}of\PYGZus{}current\PYGZus{}element}
\end{sphinxVerbatim}

\sphinxAtStartPar
This isn’t valid Python code. It won’t run if you try to put it in a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{.py}%
}} file directly. Instead, it is (hopefully) fairly easy to read and understand. It helps you to explain what you want your code to do, before you then go away and write the detailed code.

\sphinxAtStartPar
You can do a lot of your code design at the pseudocode level, without having to worry about things like: should there be a bracket here?; or is this value initialized correctly?; or other details. The details are important, but come later.

\sphinxAtStartPar
Beyond this, there are no rules or standardized syntax around pseudocode, it’s whatever you find useful. You might write quite high level pseudocode which just gives the \sphinxstyleemphasis{gist} of what has to be done, or you might write very detailed pseudocode which is very close to actual code. Both have their places. Pseudocode is a way to writing down what you want your code to do, in order to help with the design and documentation phases.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ll use pseudocode in a number of places where it’s helpful to describe the concept of what we want to do, without some of the \sphinxstyleemphasis{boilerplate} code that would actually be needed to make it work in practice (and where having such extra details would make it harder to see the core underlying concept).

\sphinxAtStartPar
In general, we don’t have any pseudocode specific tasks for you to do, but you might like to use pseudocode to rough out a solution before coding it; particularly for some of the bigger tasks we give you.
\end{sphinxadmonition}

\sphinxstepscope


\section{Co\sphinxhyphen{}pilot and other AI tools}
\label{\detokenize{chapters/software_development_tools/ai_tools:co-pilot-and-other-ai-tools}}\label{\detokenize{chapters/software_development_tools/ai_tools::doc}}
\sphinxAtStartPar
We’ve discussed generative artificial intelligence (AI) and its use in programming \sphinxhref{https://uom-eee-eeen1xxx2.github.io/chapters/course\_policies/ai\_use.html}{previously}. We won’t repeat that information here, but it is important that you read it, as AI tools can’t be used in every situation. Moreover, if you don’t understand your own code, it’s going to be very difficult for you to make it high performance, or to debug difficult cases.

\sphinxAtStartPar
Nevertheless, it’s important to have AI on the list of tools that we have at our disposal to help write correct and high performance code.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
AI tools are allowed during the course, but won’t be available during the final exam. You are advised to make suitable, but informed and responsible, use of them.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Programming fundamentals}
\label{\detokenize{chapters/programming_fundamentals:programming-fundamentals}}\label{\detokenize{chapters/programming_fundamentals:id1}}\label{\detokenize{chapters/programming_fundamentals::doc}}
\sphinxAtStartPar
Every programming language is different, and each works in a slightly different way. This is why there is, and why we learn, more than one programming language. Different languages have different pros and cons, and may better suit or not suit particular problems or constraints that are present.

\sphinxAtStartPar
Nevertheless, there a wide number of general concepts that apply across our different types of programming. Sometimes there are variations in different languages, and sometimes the same underlying concept is given different names in different places, but the approach is similar.

\sphinxAtStartPar
This part of the notes introduces some of these concepts, so that we can think about them \sphinxstyleemphasis{in theory} before getting to practicing them in the lab. We’ll mainly give examples in Python, but will also use {\hyperref[\detokenize{chapters/software_development_tools/pseudocode:pseudocode}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pseudocode}}}}} so we can focus on the underlying concepts rather than necessarily what’s needed to make them work in practice. Unless otherwise stated, assume that any code examples are in Python.

\sphinxAtStartPar
Some of the later topics, those from {\hyperref[\detokenize{chapters/programming_fundamentals/stack_and_heap:stack-and-heap}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{stack and heap memory}}}}} and after, are relatively advanced and relate more to the latter half of the course on Rust and lower level languages. You may like to revisit these later in the course.

\sphinxAtStartPar
In any program, there are two key things that we need: \sphinxstyleemphasis{data} the information we’re working with; and \sphinxstyleemphasis{operations} we can do to that data to manipulate it, extract information from it, or convert it in\sphinxhyphen{}line with whatever our needs are. The basic unit of storing data is a {\hyperref[\detokenize{chapters/programming_fundamentals/variables:variables}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{variable}}}}}. (There are then other types we’ll get to later.) The basic unit of code to manipulate data is a {\hyperref[\detokenize{chapters/programming_fundamentals/functions:functions}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{function}}}}}. We’re going to introduce functions first, but of course this makes some use of variables, and so you might need to go back and re\sphinxhyphen{}read functions once you’ve also read about variables.

\sphinxstepscope


\section{Scripts vs. programs}
\label{\detokenize{chapters/programming_fundamentals/scripts:scripts-vs-programs}}\label{\detokenize{chapters/programming_fundamentals/scripts::doc}}
\sphinxAtStartPar
Firstly, a small topic for completeness.

\sphinxAtStartPar
In early parts of the course we will speak mainly about \sphinxstyleemphasis{scripts}. In the latter parts we will speak mainly about \sphinxstyleemphasis{programs}.

\sphinxAtStartPar
We mentioned interpreted and compiled languages previously {\hyperref[\detokenize{chapters/motivation/language_types:language-types}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{previously}}}}}. A script means it’s interpreted code. That is, it runs line by line directly from the code file.

\sphinxAtStartPar
A program means it’s compiled code. Before we can run the code, our source code (e.g. a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{.rs}%
}} file) is first converted from a human readable format into something the computer can execute. This makes a new file, often (but not always) with a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{.exe}%
}} extension. It is this \sphinxstyleemphasis{executable} that the computer actually runs. If the compilation step fails, no executable will be produced and there won’t be anything for the computer to run.

\sphinxAtStartPar
This probably makes small practical difference when you’re first starting out. We wanted to mention it here to make sure you don’t get confused if you see \sphinxstyleemphasis{script} rather than \sphinxstyleemphasis{program}.

\sphinxstepscope


\section{Functions}
\label{\detokenize{chapters/programming_fundamentals/functions:functions}}\label{\detokenize{chapters/programming_fundamentals/functions:id1}}\label{\detokenize{chapters/programming_fundamentals/functions::doc}}

\subsection{Fundaments}
\label{\detokenize{chapters/programming_fundamentals/functions:fundaments}}
\sphinxAtStartPar
Functions are the basic building blocks of a code file. They are re\sphinxhyphen{}usable blocks of code that perform a clear specified operation. When getting started, the art of programming is knowing which built\sphinxhyphen{}in functions are available for you to use, how to combine these together, and how to write your own functions when the operation you need isn’t already available to use.

\sphinxAtStartPar
A simple function in Python might be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} is the name of the function. This can be whatever is meaningful to us to describe, briefly, what the function does. This particular function takes two inputs, called \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}}, with these defined by the round brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{(}\PYG{p}{)}%
}} after the function name. The function has one output (it could have more if we wanted). The output is called \sphinxcode{\sphinxupquote{%
\PYG{n}{c}%
}}, and the keyword \sphinxcode{\sphinxupquote{%
\PYG{k}{return}%
}} flags this as being the output. There’s just one line of code that does the hard work in this example, \sphinxcode{\sphinxupquote{%
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}%
}}. We could have lots and lots of lines here though if they were needed.

\sphinxAtStartPar
In another function, we can then \sphinxstyleemphasis{call} this function, and it will \sphinxstyleemphasis{return} its output. For example we might have

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If just using \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} once this isn’t necessarily that helpful, but the aim is that the \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} function is reusable. We can have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{6.43}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
    \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{22}
    \PYG{n}{e} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and use the function lots of times. This way, when testing the code, we can run {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:unit-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{unit tests}}}}} on \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}}, and when we’re confident it’s working it gives us more confidence \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}} will be working as we want.

\sphinxAtStartPar
Note that in the last call to \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} in \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}} above, we gave the inputs and outputs different names. This is completely valid and very helpful, they’re still called \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}}, and \sphinxcode{\sphinxupquote{%
\PYG{n}{c}%
}} inside the \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}}, but in the calling function \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}} we can use different names, whatever is more meaningful for that piece of code.


\subsection{The main function}
\label{\detokenize{chapters/programming_fundamentals/functions:the-main-function}}
\sphinxAtStartPar
By convention, when a program first starts it runs the function called \sphinxstyleemphasis{main}. Many programs expect a function called main to be present in any code at some point. Main gives the \sphinxstyleemphasis{entrypoint} and means that as a programmer we always know what will run first, and we can then branch off into other functions as needed from there.

\sphinxAtStartPar
For Python, but not other languages, a bit of additional code is actually needed to get it to start off by running main. This looks like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{%
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}%
}} is just part of the \sphinxstyleemphasis{boilerplate} code that we need to make things work. This example is specific to Python. It’s not needed in other programming languages, they will pick up the main function automatically. Although, other languages may well need their own boilerplate code in different places to make things work.

\sphinxAtStartPar
In general, best practice is to put as little as possible into the \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}} function. It’s better to do whatever setup is needed in \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}}, but then use other functions that you’ve made yourself to carry out the main body of work. This fits in better with our testing strategy \sphinxhyphen{} each your your functions can be made and tested with {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:unit-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{unit tests}}}}}, and then the more complicated integration tests only need to focus on when everything comes together to in \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}}, and \sphinxcode{\sphinxupquote{%
\PYG{n}{main}%
}} is kept very short to help with this.


\subsection{Closures}
\label{\detokenize{chapters/programming_fundamentals/functions:closures}}
\sphinxAtStartPar
\sphinxstyleemphasis{Closures} are a special type of function, fairly common in Rust programming. We won’t cover them more here, but will meet them when we get to those parts of the labs. We’ll cover the theory of them then, once you’ve got a bit more hands on experience of ordinary functions.

\sphinxstepscope


\section{Mutable vs. immutable}
\label{\detokenize{chapters/programming_fundamentals/mutability:mutable-vs-immutable}}\label{\detokenize{chapters/programming_fundamentals/mutability::doc}}
\sphinxAtStartPar
Before looking at {\hyperref[\detokenize{chapters/programming_fundamentals/variables:variables}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{variables}}}}}, a brief note on \sphinxstyleemphasis{mutability} is needed.

\sphinxAtStartPar
Being mutable means that a value can change. Being immutable means that it can’t. We’ll make reference to mutable variables and immutable variables in quite a few places, and they are very important when you get to Rust programming.

\sphinxAtStartPar
It might sound a bit odd to have an immutable variable, variable implies it can change but being immutable means it can’t.

\sphinxAtStartPar
This is actually quite common in programming \sphinxhyphen{} we can use it to help force us write code which is error free.

\sphinxAtStartPar
Say I have some code which loads in the list of students taking the course, and their marks. This data is variable \sphinxhyphen{} when the course is run next year there will be a different list of students taking the course. On any individual run of the code though the list of students is immutable \sphinxhyphen{} I don’t want to accidentally add or delete any students from the class roster! By making the data as immutable it makes it easier for the built in tools to detect whether the code has any errors which means it tries to change data that should be fixed.

\sphinxAtStartPar
In our programming it’s quite common that we want to take steps like this, using our knowledge of the problem to restrict the code, to help ensure the code is correct.

\sphinxstepscope


\section{Variables}
\label{\detokenize{chapters/programming_fundamentals/variables:variables}}\label{\detokenize{chapters/programming_fundamentals/variables:id1}}\label{\detokenize{chapters/programming_fundamentals/variables::doc}}

\subsection{Single variables}
\label{\detokenize{chapters/programming_fundamentals/variables:single-variables}}\label{\detokenize{chapters/programming_fundamentals/variables:id2}}
\sphinxAtStartPar
The basic unit for storing data is a \sphinxstyleemphasis{variable}. There are then lots of further variable \sphinxstyleemphasis{types} giving other ways of storing data.

\sphinxAtStartPar
Each variable has a name, and then a value stored in it. This way, in other parts of the code you can refer to the name, which will be the same whatever data is stored in the variable.

\sphinxAtStartPar
Values are put into variables by using the equals \sphinxcode{\sphinxupquote{%
\PYG{o}{=}%
}} operator. The variable name goes on the left, and the value to store goes on the right. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{pi\PYGZus{}ish} \PYG{o}{=} \PYG{l+m+mf}{3.1415}
\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alex}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{check} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{blank} \PYG{o}{=} \PYG{k+kc}{None}
\end{sphinxVerbatim}


\subsection{Storing multiple values}
\label{\detokenize{chapters/programming_fundamentals/variables:storing-multiple-values}}
\sphinxAtStartPar
Generally variables store one thing at a time. This is fine, but we often have data which has more than one \sphinxstyleemphasis{property} which needs to be stored. For example, consider the chess board shown below. (Taken from \sphinxhref{https://en.wikipedia.org/wiki/Algebraic\_notation\_\%28chess\%29}{Wikipedia}, re\sphinxhyphen{}used under \sphinxhref{https://creativecommons.org/licenses/by-sa/3.0/}{CC BY\sphinxhyphen{}SA license}.)

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{chess_board.svg}.png}
\end{figure}

\sphinxAtStartPar
Each piece has both an \sphinxstyleemphasis{x} coordinate, denoted by a letter, and a \sphinxstyleemphasis{y} coordinate, denoted by a number. It doesn’t make any conceptual sense for a piece to have an \sphinxstyleemphasis{x} coordinate but not a \sphinxstyleemphasis{y} coordinate. That wouldn’t correspond to any valid place for a playing piece to be. Thus, while the below would work

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{piece1\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
it probably isn’t the best way of doing it. It would be easy to have a single typo, say \sphinxcode{\sphinxupquote{%
\PYG{n}{piece2\PYGZus{}y}%
}} and you’ll start getting strange behavior.

\sphinxAtStartPar
Instead there are multiple different ways in which multiple pieces of information can be grouped together under a common variable name. (Here we won’t worry about the fact that in chess there are also multiple pieces which you might want to group to help you keep track of them.)


\subsection{Tuples}
\label{\detokenize{chapters/programming_fundamentals/variables:tuples}}
\sphinxAtStartPar
A \sphinxstyleemphasis{tuple} groups data together inside round brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{(}\PYG{p}{)}%
}} separated by commas \sphinxcode{\sphinxupquote{%
\PYG{p}{,}%
}}. For the example above, the position could thus be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are now two pieces of information, a \sphinxstyleemphasis{x} coordinate and a \sphinxstyleemphasis{y} coordinate both fundamentally stored under a single name to help keep them together.

\sphinxAtStartPar
The individual \sphinxstyleemphasis{elements} in a list can be accessed by using square brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{[}\PYG{p}{]}%
}} and a number as an \sphinxstyleemphasis{address}. These addresses start at 0. So, \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{3}%
}}.

\sphinxAtStartPar
In this simple example there are only two pieces of information in the tuple. You can of course have much larger tuples if needed to store the different items that you’re working with.

\sphinxAtStartPar
Tuples are \sphinxstyleemphasis{immutable}. Once made the contents can’t be changed.


\subsection{Lists}
\label{\detokenize{chapters/programming_fundamentals/variables:lists}}\label{\detokenize{chapters/programming_fundamentals/variables:id3}}
\sphinxAtStartPar
A \sphinxstyleemphasis{list} groups data together inside square brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{[}\PYG{p}{]}%
}} separated by commas \sphinxcode{\sphinxupquote{%
\PYG{p}{,}%
}}. For the example above, the position could thus be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The individual elements in a list can be accessed by using square brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{[}\PYG{p}{]}%
}} and a number as an \sphinxstyleemphasis{address}. These addresses start at 0. So, \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{3}%
}}.

\sphinxAtStartPar
In this simple example there are only two pieces of information in the list. You can of course have much larger lists if needed to store the different items that you’re working with.

\sphinxAtStartPar
The main difference from a tuple is that lists are \sphinxstyleemphasis{mutable}. You can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
to update or change the values that are stored in the list. There are more commands, which we’ll meet in the labs, for adding or removing elements from a list.


\subsection{Dictionaries}
\label{\detokenize{chapters/programming_fundamentals/variables:dictionaries}}\label{\detokenize{chapters/programming_fundamentals/variables:id4}}
\sphinxAtStartPar
A \sphinxstyleemphasis{dictionary} groups data together inside curly brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}%
}} and in addition to the raw information to be stored, each piece of information is given its own name known as a \sphinxstyleemphasis{key}. \sphinxcode{\sphinxupquote{%
\PYG{p}{,}%
}}. You get to pick the key names. For the example above, the position could thus be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The individual elements in a dictionary can be accessed by using square brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{[}\PYG{p}{]}%
}} and the key name. So, \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}%
}} contains \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{3}%
}}.

\sphinxAtStartPar
In this simple example there are only two pieces of information in the dictionary. You can of course have much larger dictionaries if needed to store the different items that you’re working with.

\sphinxAtStartPar
Dictionaries are mutable. The main difference from tuples and lists is that you use a key, here \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}%
}} or \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}%
}}, as the \sphinxstyleemphasis{address} of the data, rather than a number. In various cases this might help make the code more readable.


\subsection{Multi\sphinxhyphen{}dimensional items}
\label{\detokenize{chapters/programming_fundamentals/variables:multi-dimensional-items}}
\sphinxAtStartPar
The above examples are all one\sphinxhyphen{}dimensional. For example we had \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}%
}}. We can have multi\sphinxhyphen{}dimensional items as well. For example, a 2D list might look like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{%
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}} contains 0.

\sphinxAtStartPar
Alternatively, as a second example, you can store tuples in a dictionary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{piece1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{piece2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
By combining variable types, you can build up some quite complicated and multi\sphinxhyphen{}dimensional data structures.


\subsection{Which should I use}
\label{\detokenize{chapters/programming_fundamentals/variables:which-should-i-use}}
\sphinxAtStartPar
You might find that there are performance differences between the different ways of storing data, for your problem some may execute faster than others.

\sphinxAtStartPar
More generally, you should use whichever fits the type of data/problem that you have to work with, to try and \sphinxstyleemphasis{force} the code to be correct.

\sphinxAtStartPar
For a chess piece, a tuple probably doesn’t fit \sphinxhyphen{} a chess piece has to move and so it’s position should be stored in a variable type which can be changed and updated. Both a list or a dictionary are probably fine. A dictionary might give more readable code. \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}%
}} is a bit more clear that it’s the \sphinxstyleemphasis{x} location, compared to \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}} where you have to remember 0 represents the \sphinxstyleemphasis{x} coorinate. Remember, with a dictionary you get to pick the key names, and so you can use names that are meaningful to you.


\subsection{Other variable types}
\label{\detokenize{chapters/programming_fundamentals/variables:other-variable-types}}
\sphinxAtStartPar
There are many more variable types (sometimes called \sphinxstyleemphasis{collections}) beyond the three listed here. These are just the \sphinxstyleemphasis{getting started} ones. You’ll likely encounter more as you get further into your Python programming, and so don’t assume these are all there is.

\sphinxAtStartPar
For electronic engineering in particular, in Python it’s very common to use \sphinxstyleemphasis{numpy arrays} as a variable type. We’ll see these in the labs.

\sphinxstepscope


\section{Objects}
\label{\detokenize{chapters/programming_fundamentals/objects:objects}}\label{\detokenize{chapters/programming_fundamentals/objects:id1}}\label{\detokenize{chapters/programming_fundamentals/objects::doc}}
\sphinxAtStartPar
Objects are where {\hyperref[\detokenize{chapters/programming_fundamentals/functions:functions}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{functions}}}}} and {\hyperref[\detokenize{chapters/programming_fundamentals/variables:variables}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{variables}}}}} come together. Let’s give an example to show why this is useful, and can help us write correct code.


\subsection{Example motivating objects}
\label{\detokenize{chapters/programming_fundamentals/objects:example-motivating-objects}}
\sphinxAtStartPar
When discussing {\hyperref[\detokenize{chapters/programming_fundamentals/variables:variables}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{variables}}}}} we had an example of storing the coordinates of a chess piece. Using a list, the \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y} coordinates might be stored as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s say our program also has to store the location of the city Manchester. (Maybe there is a chess tournament in Manchester!) This is 53.4808, \sphinxhyphen{}2.2426, where these are longitude and latitude numbers. Fundamentally, it’s still two information items which define the location of the city. We could store these as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{manchester\PYGZus{}pos} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{53.4808}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2426}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, let’s say we have two different things that we want to do:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Move a chess piece to a different location.

\item {} 
\sphinxAtStartPar
Lookup the population living within 10 miles of the city centre.

\end{itemize}

\sphinxAtStartPar
We could write functions to do both of these. We’ll switch to {\hyperref[\detokenize{chapters/software_development_tools/pseudocode:pseudocode}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pseudocode}}}}} for these, as exactly how we would implement these is not critical at this point. The outline of the functions might be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{move}\PYG{p}{(}\PYG{n}{item\PYGZus{}to\PYGZus{}move}\PYG{p}{,} \PYG{n}{x\PYGZus{}new}\PYG{p}{,} \PYG{n}{y\PYGZus{}new}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{item\PYGZus{}to\PYGZus{}move}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x\PYGZus{}new}
    \PYG{n}{item\PYGZus{}to\PYGZus{}move}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y\PYGZus{}new}
    \PYG{k}{return} \PYG{n}{item\PYGZus{}to\PYGZus{}move}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find\PYGZus{}population}\PYG{p}{(}\PYG{n}{location}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{area} \PYG{o}{=} \PYG{n}{draw\PYGZus{}10mile\PYGZus{}circle\PYGZus{}centred\PYGZus{}on}\PYG{p}{(}\PYG{n}{location}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{location}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{population} \PYG{o}{=} \PYG{n}{search\PYGZus{}for\PYGZus{}population\PYGZus{}in}\PYG{p}{(}\PYG{n}{area}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{population}
\end{sphinxVerbatim}

\sphinxAtStartPar
These functions would work fine, as long as we always pass the correct variables to them. It doesn’t make any conceptual sense to look up the population around a chess piece, or to move the location of the city. There’s nothing in the code that prevents us from doing this though. Code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{manchester\PYGZus{}pos} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{53.4808}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2426}\PYG{p}{]}
\PYG{n}{manchester\PYGZus{}pos} \PYG{o}{=} \PYG{n}{move}\PYG{p}{(}\PYG{n}{manchester\PYGZus{}pos}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
will likely run just fine. The code design isn’t helping us to avoid strange bugs. This is of course a simple example, but when there’s thousands of lines of code, and multiple different people working as part of a team, you want to try and use the code design to avoid mistakes like this.

\sphinxAtStartPar
\sphinxstyleemphasis{Objects} are like a \sphinxstyleemphasis{super variable}, they store data, and functions that apply to that data. In these cases, the functions are known as \sphinxstyleemphasis{methods}. In the example above, \sphinxcode{\sphinxupquote{%
\PYG{n}{move}%
}} could be a method for a \sphinxcode{\sphinxupquote{%
\PYG{n}{chess\PYGZus{}piece}%
}} object, while \sphinxcode{\sphinxupquote{%
\PYG{n}{find\PYGZus{}population}%
}} a method for a \sphinxcode{\sphinxupquote{%
\PYG{n}{city\PYGZus{}location}%
}} object. Only chess pieces would be allowed to call \sphinxcode{\sphinxupquote{%
\PYG{n}{move}%
}}, and city locations call \sphinxcode{\sphinxupquote{%
\PYG{n}{find\PYGZus{}population}%
}}, and so it prevents people doing incorrect things with data.

\sphinxAtStartPar
Functions of course are widely used as well as object methods; you just need to think whether the operations are general for whatever input might be provided (make a function), or whether they’re specific to a particular data arrangement that you’re working with (make an object and method).


\subsection{Object basics}
\label{\detokenize{chapters/programming_fundamentals/objects:object-basics}}
\sphinxAtStartPar
You can make an object by either: defining a \sphinxstyleemphasis{class} which has the code for the data and methods you want; or using \sphinxstyleemphasis{inheritance}, that is, using an existing class as a starting point and adding or removing functionally from this. We’ll see some examples of making classes in the labs, and won’t so won’t consider it more here.

\sphinxAtStartPar
A class defines the general properties that an object can have. It’s kind of like a template An \sphinxstyleemphasis{instance} is then one object that is made to that class template. We could have multiple instances of the same class, such as \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{n}{piece2\PYGZus{}pos}%
}}. These instances will have the same methods that can be applied, but will be separate instances that can store different data.

\sphinxAtStartPar
You use a method associated with an object, usually by having dot \sphinxcode{\sphinxupquote{%
\PYG{o}{.}%
}} after the instance name, and then the name of method you want to call. In the above examples, you thus might have code along the lines of

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos}\PYG{o}{.}\PYG{n}{move}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{manchester\PYGZus{}pos}\PYG{o}{.}\PYG{n}{find\PYGZus{}population}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Particularly in Python, lots of things are actually objects. For example, {\hyperref[\detokenize{chapters/programming_fundamentals/variables:lists}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{lists}}}}} and {\hyperref[\detokenize{chapters/programming_fundamentals/variables:dictionaries}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{dictionaries}}}}} are actually stored as objects, with methods to give them extra functionality. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
returns the keys that are used with the dictionary (\sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}%
}} here).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
removes all of the entries in \sphinxcode{\sphinxupquote{%
\PYG{n}{piece1\PYGZus{}pos\PYGZus{}d}%
}}.

\sphinxAtStartPar
In general, an object has \sphinxstyleemphasis{attributes} which are accessed by having a dot \sphinxcode{\sphinxupquote{%
\PYG{o}{.}%
}} after the object name. Methods are one example of attributes.

\sphinxAtStartPar
There are many more methods that can be used with common objects. There are also many more rules for how we make and work with classes. We’ll see some of these in the labs.

\sphinxstepscope


\section{Data types}
\label{\detokenize{chapters/programming_fundamentals/data_types:data-types}}\label{\detokenize{chapters/programming_fundamentals/data_types::doc}}

\subsection{Overview}
\label{\detokenize{chapters/programming_fundamentals/data_types:overview}}
\sphinxAtStartPar
Behind the scenes, computers work in \sphinxstyleemphasis{binary}. Everything is stored as either a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0}%
}} or a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{1}%
}}. Many of the details of this are not important for this course, you’ll go into detail on binary in your digital electronics courses. However, we always need to remember this, as it shapes how and why computers and programs work the way they do.

\sphinxAtStartPar
For our programs, we need a way of going between the \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0}%
}}’s and a \sphinxcode{\sphinxupquote{%
\PYG{g+go}{1}%
}}’s that a computer works with, and the data a human works with. We’re used to dealing with numbers (e.g. 0, 8, 22.3), or text (e.g. “\sphinxstyleemphasis{hello}”), or dates (05.11.1955), and many other formats.

\sphinxAtStartPar
To do this, there are two things built in to our programming. Firstly, there is an agreed on \sphinxstyleemphasis{standard}. If we all agree that \sphinxcode{\sphinxupquote{%
\PYG{g+go}{01001101}%
}} represents the letter \sphinxcode{\sphinxupquote{%
\PYG{g+go}{M}%
}}, then we can work with that. There are well established standards for how computers represent common types of data (e.g. IEEE/ISO/IEC 60559 for storing numbers that have decimal points). In general, we won’t worry about these in this course. The computer knows the standard for us, and we only need to go into a little depth on the following pages.

\sphinxAtStartPar
Secondly, each thing we store in our code, whether via a variable or in an object, is given a \sphinxstyleemphasis{data type}. The program is given some additional information to help it know what kind of information is being kept. For example, in Python, if you have

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alex}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
the double quotes \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}%
}} help indicate that this is storing text.


\subsection{Common data types}
\label{\detokenize{chapters/programming_fundamentals/data_types:common-data-types}}
\sphinxAtStartPar
There are a number of common data types, and we’ll introduce the properties of some important ones on the following pages. It’s not necessary to know all of the details of these, but it is important to have some understanding of how our data is being used by the computer \sphinxstyleemphasis{under\sphinxhyphen{}the\sphinxhyphen{}hood}. Having some familiarity will help you debug when you have issues with your data.

\sphinxstepscope


\subsubsection{Booleans}
\label{\detokenize{chapters/programming_fundamentals/booleans:booleans}}\label{\detokenize{chapters/programming_fundamentals/booleans::doc}}
\sphinxAtStartPar
Computers operate in binary, where there are only two states. These might be 0/1, or Yes/No, or True/False. These are all different human\sphinxhyphen{}interpretable ways of representing fundamentally the same thing, something which can only have two distinct states.

\sphinxAtStartPar
In our programs these are usually represented as \sphinxcode{\sphinxupquote{%
\PYG{k+kc}{True}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{k+kc}{False}%
}}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{check} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Integers}
\label{\detokenize{chapters/programming_fundamentals/integers:integers}}\label{\detokenize{chapters/programming_fundamentals/integers::doc}}
\sphinxAtStartPar
An integer refers to a whole number, e.g. 0, 1, 2, 55. Integers can also be negative, e.g. \sphinxhyphen{}1, \sphinxhyphen{}22.

\sphinxAtStartPar
It’s very common to have integers when working with computer code. For example, maybe we want to store how many students are taking the class. Or, count how many files are stored on the computer. It doesn’t make any conceptual sense for there to be 202.5 students taking the class. We’d thus store the number of students as an integer.


\paragraph{How the computer stores them}
\label{\detokenize{chapters/programming_fundamentals/integers:how-the-computer-stores-them}}
\sphinxAtStartPar
Within the computer memory, data is stored in binary. If we have

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The number \sphinxcode{\sphinxupquote{%
\PYG{g+go}{2}%
}} isn’t stored directly, its binary representation is.

\sphinxAtStartPar
The number of bits used to store an integer varies depending on the operating system of the computer, the architecture of the processor present, and how many bits you ask for. As a default, many computers use 32 bits. In this case, \sphinxcode{\sphinxupquote{%
\PYG{g+go}{2}%
}} would be stored in the computer memory as \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0000 0000 0000 0000 0000 0000 0000 0010}%
}}.

\sphinxAtStartPar
Negative numbers are stored using \sphinxhref{https://en.wikipedia.org/wiki/Two\%27s\_complement/}{2’s complement format}, which you’ll learn about in digital electronics courses. Briefly, the \sphinxstyleemphasis{left\sphinxhyphen{}most} bit as we’re writing them is used as a sign bit. \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0}%
}} represents a positive number, while \sphinxcode{\sphinxupquote{%
\PYG{g+go}{1}%
}} indicates that a negative number is present. As examples:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{3}%
}} would be stored as \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0000 0000 0000 0000 0000 0000 0000 0011}%
}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZhy{}2}%
}} would be stored as \sphinxcode{\sphinxupquote{%
\PYG{g+go}{1111 1111 1111 1111 1111 1111 1111 1110}%
}}.\textasciigrave{}

\end{itemize}

\sphinxAtStartPar
To help further with checking our code, integers can be flagged as being \sphinxstyleemphasis{signed} or \sphinxstyleemphasis{unsigned}. Signed means the number could be positive or negative. Unsigned means it can only be positive. Rather than using an integer, when counting the number of students in the class, or the number of files on a computer, using an unsigned integer could be best \sphinxhyphen{} these numbers can only be positive so they should be stored in a data type which only accepts postive numbers.

\sphinxAtStartPar
In an unsigned integer, all of the bits in the word are used to represent the number. Thus:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{1111 1111 1111 1111 1111 1111 1111 1110}%
}} represents 4,294,967,294.

\end{itemize}

\sphinxAtStartPar
It’s not that unsigned integers take the absolute value of a number. Rather, numbers that would be negative if they were signed are interpreted as large positive numbers, because of the extra bit available when no sign bit is used.


\paragraph{Consequences of this storage}
\label{\detokenize{chapters/programming_fundamentals/integers:consequences-of-this-storage}}
\sphinxAtStartPar
As a finite number of bits are used to store an integer, there is a maximum and minimum number that they can store. For a 32 bit signed integer the maximum number possible would be:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{0111 1111 1111 1111 1111 1111 1111 1111}%
}}.

\end{itemize}

\sphinxAtStartPar
which is \(2^{31} -1\) which is 2,147,483,647. The minimum number would be:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{1000 0000 0000 0000 0000 0000 0000 0000}%
}}.

\end{itemize}

\sphinxAtStartPar
which is \sphinxhyphen{}2,147,483,648.

\sphinxAtStartPar
For an unsigned 32 bit integer, the maximum number is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{1111 1111 1111 1111 1111 1111 1111 1111}%
}}.

\end{itemize}

\sphinxAtStartPar
which is \(2^{32} -1\) which is 4,294,967,295. The minimum number is 0.

\sphinxAtStartPar
You get \sphinxstyleemphasis{overflow} or \sphinxstyleemphasis{underflow} if you try and store/use an integer which is outside of these ranges. In Python, these error cases are automatically handled for you, you won’t get overflow or underflow errors in most cases. In other programming languages, if working with very large numbers you may need to be aware, and have some checks for, this.


\paragraph{Number representations}
\label{\detokenize{chapters/programming_fundamentals/integers:number-representations}}
\sphinxAtStartPar
In this course, we’re mainly working with small numbers, such as 100. It’s easy enough to type these in directly. However, we can also type in numbers in binary, and \sphinxstyleemphasis{hexadecimal} (hex) forms, which are useful in many situations.

\sphinxAtStartPar
A hex representation of a number uses the numbers 0\sphinxhyphen{}9 and letters A\sphinxhyphen{}F to represent a single number. This gives 16 characters, and so 1 character (0\sphinxhyphen{}9 or A\sphinxhyphen{}F) can represent the 16 different possible things that 4 bits (e.g. 0110) could represent. It’s thus much more compact than writing out a long binary word, or indeed using a decimal number.

\sphinxAtStartPar
To enter a hex number you preface it with \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0x}%
}}. To enter a binary number, you preface the number with \sphinxcode{\sphinxupquote{%
\PYG{g+go}{0b}%
}}. You can thus enter 100 as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{j} \PYG{o}{=} \PYG{l+m+mh}{0x64}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mb}{0b01100100}
\end{sphinxVerbatim}

\sphinxAtStartPar
All of these represent exactly the same thing, they are just different ways of entering it into the computer.

\sphinxAtStartPar
When working with hex numbers, the letters can be either upper or lower case.

\sphinxAtStartPar
All of these store exactly the same thing in memory, they are just different ways of entering the same number. Sometimes using one form is simpler than using another, and you can switch between them to use whichever is simplest.

\sphinxAtStartPar
If using Windows, you can use the \sphinxstyleemphasis{Programmer} view of the Calculator app to present the same number using different representations. Other operating systems have similar calculators available.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{calculator}.png}
\end{figure}


\paragraph{Which should I use}
\label{\detokenize{chapters/programming_fundamentals/integers:which-should-i-use}}
\sphinxAtStartPar
If you have to specify a type of integer, e.g. in Rust, probably use 32 bits \sphinxcode{\sphinxupquote{%
\PYG{k+kt}{i32}%
}} as the default starting point. Then think about whether you’re dealing with numbers which can only be positive, e.g. the number of students in a class. If so, switch to using an unsigned integer \sphinxcode{\sphinxupquote{%
\PYG{k+kt}{u32}%
}}. Then think about whether you’re likely to deal with such large numbers that you might get overflow. If so, take the number of bits used up. This will come at the cost of performance though. Bigger isn’t better if you don’t need such high numbers.

\sphinxstepscope


\subsubsection{Floating point numbers}
\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers:floating-point-numbers}}\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers::doc}}
\sphinxAtStartPar
Numbers which aren’t integers, i.e. those with decimal places, are stored as \sphinxstyleemphasis{floating point numbers}.

\sphinxAtStartPar
Most computers use a standard known as IEEE/ISO/IEC 60559 to define how we interpret the binary bits that are stored on a computer as a number with decimal places. This standard defines multiple types of floating point number, mainly:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Single}. Also known as a \sphinxstyleemphasis{float}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Double}.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Quad}.

\end{itemize}


\paragraph{How the computer stores them}
\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers:how-the-computer-stores-them}}
\sphinxAtStartPar
We won’t go into the details of how a computer stores floating point numbers. You can read about the details of interpreting some bits as a \sphinxstyleemphasis{mantissa} and other bits as the \sphinxstyleemphasis{exponent} \sphinxhref{https://en.wikipedia.org/wiki/Floating-point\_arithmetic}{elsewhere} if you’re interested.

\sphinxAtStartPar
The important point is that 32 bits are used to store a single, 64 bits for a double, and 128 bits for a quad.


\paragraph{Consequences of this storage}
\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers:consequences-of-this-storage}}
\sphinxAtStartPar
As with integers, as we’re using a finite number of bits to store a number, and that means there are a finite number of numbers that can be represented. There’s a maximum possible number that can be represented, a smallest possible number, and a smallest step change between numbers that’s possible.The table below gives an indication of the precision.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{10}{50}\X{15}{50}\X{15}{50}\X{10}{50}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Smallest possible value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Largest possible value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Precision
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
float
&
\sphinxAtStartPar
\(1.17549 \times 10^{-38}\)
&
\sphinxAtStartPar
\(3.40282 \times 10^{38}\)
&
\sphinxAtStartPar
6 digits
\\
\sphinxhline
\sphinxAtStartPar
double
&
\sphinxAtStartPar
\(2.22507 \times 10^{-308}\)
&
\sphinxAtStartPar
\(1.79769 \times 10^{308}\)
&
\sphinxAtStartPar
15 digits
\\
\sphinxhline
\sphinxAtStartPar
quad
&
\sphinxAtStartPar
\(3.3621 \times 10^{−4932}\)
&
\sphinxAtStartPar
\(1.1897 \times 10^{4932}\)
&
\sphinxAtStartPar
38 digits
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
What we find, very quickly, is that not every possible number can be represented exactly as a floating point number. The example below shows an easy number, 4.2, being stored in a variable, and this variable being viewed in the {\hyperref[\detokenize{chapters/software_development_tools/debugger:debugger}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{debugger}}}}}. What is actually stored is 4.2000000000000002. (This example is using Rust, where \sphinxcode{\sphinxupquote{%
\PYG{k+kt}{f64}%
}} sets the data type to be a double.)

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{floating_point_error}.png}
\end{figure}

\sphinxAtStartPar
Numbers can have an infinite number of decimal places, but we only have a finite number of bits available in a computer to store a number in. It’s thus common to get a small amount of \sphinxstyleemphasis{floating point error}.

\sphinxAtStartPar
In many situations this numerical rounding is negligible. 4.2000000000000002 is correctly representing 4.2 to 15 decimal places! This is more than enough for most situations. Imagine this 4.2 was representing a voltage that you measured from a circuit in the lab. The number would be off by 0.2 fV. That’s \(10^{-15}\) V. It’s basically impossible to measure voltages that precisely, there will always be thermal or measurement or some other source of noise (which you’ll learn about in your practical electronics courses) that are larger. The fact that there’s some numerical noise as well, is just another source of noise.

\sphinxAtStartPar
Nevertheless, floating point error can be important to consider in some high performance situations, or if the error accumulates over multiple calculations, and so you need to be aware of it.


\paragraph{Number representations}
\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers:number-representations}}
\sphinxAtStartPar
You can enter floating point numbers in a number of different ways. This includes using an \sphinxcode{\sphinxupquote{%
\PYG{g+go}{e}%
}} or \sphinxcode{\sphinxupquote{%
\PYG{g+go}{E}%
}} to represent an exponent (that is, a \(\times 10 ^{p}\) factor, where \(p\) is the number that comes after the exponent.) For example, the below are all valid ways of entering the number 57:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{57}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{57.0}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{57.0e0}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{57E0}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{5.7e1}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{5.7e+1}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{0.57e2}%
}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{570.0e\PYGZhy{}2}%
}}

\end{itemize}

\sphinxAtStartPar
(57 is an integer, but all integers can of course also be stored as floats. Not all floats are integers though!)


\paragraph{Which should I use}
\label{\detokenize{chapters/programming_fundamentals/floating_point_numbers:which-should-i-use}}
\sphinxAtStartPar
Today, most programs for desktop/laptop type devices probably use double precision numbers by default, and no further thought is required. We suggest you stick with this, and you’ll probably know, quite readily, if you’re in a higher performance situation where it requires a bit more thought.

\sphinxAtStartPar
For programs which have to be highly optimized for memory performance, or on embedded platforms, singles can be useful, as long as a little more numerical noise can be tolerated by the application. In general quads are overkill for most applications. Doubles provide more than enough accuracy, and so there’s no benefit to taking a performance hit on the amount of memory needed, unless you’re in a situation which really demands very small or very large numbers (or differences between numbers) to be represented. You’ll probably know such a situation when we see it.

\sphinxstepscope


\subsubsection{Text encoding}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:text-encoding}}\label{\detokenize{chapters/programming_fundamentals/text_encoding:id1}}\label{\detokenize{chapters/programming_fundamentals/text_encoding::doc}}
\sphinxAtStartPar
There are multiple different standards for how computers store and represent text.


\paragraph{ASCII}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:ascii}}\label{\detokenize{chapters/programming_fundamentals/text_encoding:id2}}
\sphinxAtStartPar
ASCII stands for the American Standard for Information Interchange. It is the oldest, and extremely common, standard for how letters and characters (e.g. punctuation) are represented as binary numbers.

\sphinxAtStartPar
We often refer to \sphinxstyleemphasis{plain text}, and by this we mean text represented by ASCII (or UTF\sphinxhyphen{}8, see below). ASCII is so common that it’s extremely unlikely you’ll encounter a computer system that’s in use today which wouldn’t be able to take ASCII text input and display the associated letters if you asked it to. It’s a very robust format to be working with.

\sphinxAtStartPar
ASCII uses a very simple encoding system. So simple that the full table is displayed at the bottom of this page. Each letter, and a number of other characters such as full stops, are given a binary number that represents them. (The binary number can of course also be represented in decimal form.) If the computer sees this number, and is asked to interpret it as a character, it’s the character that gets displayed. A table of ASCII characters and the numbers used to represent each character is given below. ASCII uses 7 bits to store a character, and so there are 128 possible characters that it can represent. Some of the early ones represent control signals for a computer, rather than letters.


\paragraph{Latin\sphinxhyphen{}I}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:latin-i}}
\sphinxAtStartPar
While very robust, and recognized by essentially every computer, the big limitation of ASCII is that it basically assumes you are writing English, using the 26 letters of the English alphabet. It is not very inclusive, and does not allow characters from other languages to be used.

\sphinxAtStartPar
Latin\sphinxhyphen{}I was an updated version of ASCII which used 8 bits rather than 7 to represent each character. This allowed the character map to have numbers representing 256 characters rather than 128, and so it supports many character accents, as used in many European languages.


\paragraph{Unicode and UTF\sphinxhyphen{}8 (and similar)}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:unicode-and-utf-8-and-similar}}
\sphinxAtStartPar
Unicode and UTF\sphinxhyphen{}8 (and UTF\sphinxhyphen{}16 and UTF\sphinxhyphen{}32) are how plain text is represented in modern computer systems. You may still encounter some older computer systems in use which only recognize ASCII, but in general if you say \sphinxstyleemphasis{plain text} today, this would probably be assumed to be Unicode encoded in UTF\sphinxhyphen{}8. Your programming files are being written in plain text, most likely UFT\sphinxhyphen{}8 plain text, and VSCode shows you the encoding used for your text file at the bottom of the screen.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{encoding_in_vscode}.png}
\end{figure}

\sphinxAtStartPar
The encoding scheme, mapping letters to binary numbers computers can store, is more complicated with Unicode and UFT\sphinxhyphen{}8 and the details are not important here. The major benefit of UTF\sphinxhyphen{}8/16/32 based schemes is that essentially every character from any language can be represented. It is much more inclusive and should be the default.

\sphinxAtStartPar
The negative of UTF\sphinxhyphen{}8/16/32 based schemes is that there are lots of characters that look very similar. For example, \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZsq{}}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{g+go}{’}%
}} are both characters for quotes, one is curved and one is straight. It’s easy to get the wrong one! Especially if copying and pasting between different programs and/or the Internet. In general, programming files expect a straight quote symbol \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZsq{}}%
}}. You’ll get an error if you try and put \sphinxcode{\sphinxupquote{%
\PYG{g+go}{’}%
}} in your code.

\sphinxAtStartPar
This is just one example. You can get some very hard to spot errors in your text files with characters that look very similar, but are in fact different ones. Occasionally, switching the encoding to ASCII can be useful as it’s more limited character set limits what can be entered to the correct symbols.


\paragraph{Which should I use}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:which-should-i-use}}
\sphinxAtStartPar
Most modern files and programs will accept UTF\sphinxhyphen{}8. You shouldn’t need to worry about text encoding more this until you get to more advanced programming.


\paragraph{ASCII encoding table}
\label{\detokenize{chapters/programming_fundamentals/text_encoding:ascii-encoding-table}}
\sphinxAtStartPar
The ASCII encoding table, where each letter is represented by a number, is given below. Some of the early ones represent control signals for a computer, rather than letters. (You won’t be asked to memorise this for the exam! It’s just an illustration of the encoding to help your understanding.)


\begin{savenotes}
\sphinxatlongtablestart
\sphinxthistablewithglobalstyle
\makeatletter
  \LTleft \@totalleftmargin plus1fill
  \LTright\dimexpr\columnwidth-\@totalleftmargin-\linewidth\relax plus1fill
\makeatother
\begin{longtable}{\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}\X{10}{90}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\endfirsthead

\multicolumn{9}{c}{\sphinxnorowcolor
    \makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}%
}\\
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Binary number
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number as an integer
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\endhead

\sphinxbottomrule
\multicolumn{9}{r}{\sphinxnorowcolor
    \makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}%
}\\
\endfoot

\endlastfoot
\sphinxtableatstartofbodyhook

\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
Null
&
\sphinxAtStartPar
101011
&
\sphinxAtStartPar
43
&
\sphinxAtStartPar
+
&
\sphinxAtStartPar
1010110
&
\sphinxAtStartPar
86
&
\sphinxAtStartPar
V
\\
\sphinxhline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Start of heading
&
\sphinxAtStartPar
101100
&
\sphinxAtStartPar
44
&
\sphinxAtStartPar
,
&
\sphinxAtStartPar
1010111
&
\sphinxAtStartPar
87
&
\sphinxAtStartPar
W
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Start of text
&
\sphinxAtStartPar
101101
&
\sphinxAtStartPar
45
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
1011000
&
\sphinxAtStartPar
88
&
\sphinxAtStartPar
X
\\
\sphinxhline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
End of text
&
\sphinxAtStartPar
101110
&
\sphinxAtStartPar
46
&
\sphinxAtStartPar
.
&
\sphinxAtStartPar
1011001
&
\sphinxAtStartPar
89
&
\sphinxAtStartPar
Y
\\
\sphinxhline
\sphinxAtStartPar
100
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
End of transmission
&
\sphinxAtStartPar
101111
&
\sphinxAtStartPar
47
&
\sphinxAtStartPar
/
&
\sphinxAtStartPar
1011010
&
\sphinxAtStartPar
90
&
\sphinxAtStartPar
Z
\\
\sphinxhline
\sphinxAtStartPar
101
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
Enquiry
&
\sphinxAtStartPar
110000
&
\sphinxAtStartPar
48
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1011011
&
\sphinxAtStartPar
91
&
\sphinxAtStartPar
{[}
\\
\sphinxhline
\sphinxAtStartPar
110
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
Acknowledge
&
\sphinxAtStartPar
110001
&
\sphinxAtStartPar
49
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1011100
&
\sphinxAtStartPar
92
&
\sphinxAtStartPar
\textbackslash{}
\\
\sphinxhline
\sphinxAtStartPar
111
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
Bell, alert
&
\sphinxAtStartPar
110010
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1011101
&
\sphinxAtStartPar
93
&
\sphinxAtStartPar
{]}
\\
\sphinxhline
\sphinxAtStartPar
1000
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
Backspace
&
\sphinxAtStartPar
110011
&
\sphinxAtStartPar
51
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
1011110
&
\sphinxAtStartPar
94
&
\sphinxAtStartPar
\textasciicircum{}
\\
\sphinxhline
\sphinxAtStartPar
1001
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
Horizontal tab
&
\sphinxAtStartPar
110100
&
\sphinxAtStartPar
52
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
1011111
&
\sphinxAtStartPar
95
&
\sphinxAtStartPar
\_
\\
\sphinxhline
\sphinxAtStartPar
1010
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Line feed
&
\sphinxAtStartPar
110101
&
\sphinxAtStartPar
53
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
1100000
&
\sphinxAtStartPar
96
&
\sphinxAtStartPar
\textasciigrave{}
\\
\sphinxhline
\sphinxAtStartPar
1011
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Vertical tab
&
\sphinxAtStartPar
110110
&
\sphinxAtStartPar
54
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
1100001
&
\sphinxAtStartPar
97
&
\sphinxAtStartPar
a
\\
\sphinxhline
\sphinxAtStartPar
1100
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
Form feed
&
\sphinxAtStartPar
110111
&
\sphinxAtStartPar
55
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
1100010
&
\sphinxAtStartPar
98
&
\sphinxAtStartPar
b
\\
\sphinxhline
\sphinxAtStartPar
1101
&
\sphinxAtStartPar
13
&
\sphinxAtStartPar
Carriage return
&
\sphinxAtStartPar
111000
&
\sphinxAtStartPar
56
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
1100011
&
\sphinxAtStartPar
99
&
\sphinxAtStartPar
c
\\
\sphinxhline
\sphinxAtStartPar
1110
&
\sphinxAtStartPar
14
&
\sphinxAtStartPar
Shift out
&
\sphinxAtStartPar
111001
&
\sphinxAtStartPar
57
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
1100100
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
d
\\
\sphinxhline
\sphinxAtStartPar
1111
&
\sphinxAtStartPar
15
&
\sphinxAtStartPar
Shift in
&
\sphinxAtStartPar
111010
&
\sphinxAtStartPar
58
&
\sphinxAtStartPar
:
&
\sphinxAtStartPar
1100101
&
\sphinxAtStartPar
101
&
\sphinxAtStartPar
e
\\
\sphinxhline
\sphinxAtStartPar
10000
&
\sphinxAtStartPar
16
&
\sphinxAtStartPar
Data link escape
&
\sphinxAtStartPar
111011
&
\sphinxAtStartPar
59
&
\sphinxAtStartPar
;
&
\sphinxAtStartPar
1100110
&
\sphinxAtStartPar
102
&
\sphinxAtStartPar
f
\\
\sphinxhline
\sphinxAtStartPar
10001
&
\sphinxAtStartPar
17
&
\sphinxAtStartPar
Device control one
&
\sphinxAtStartPar
111100
&
\sphinxAtStartPar
60
&
\sphinxAtStartPar
\textless{}
&
\sphinxAtStartPar
1100111
&
\sphinxAtStartPar
103
&
\sphinxAtStartPar
g
\\
\sphinxhline
\sphinxAtStartPar
10010
&
\sphinxAtStartPar
18
&
\sphinxAtStartPar
Device control two
&
\sphinxAtStartPar
111101
&
\sphinxAtStartPar
61
&
\sphinxAtStartPar
=
&
\sphinxAtStartPar
1101000
&
\sphinxAtStartPar
104
&
\sphinxAtStartPar
h
\\
\sphinxhline
\sphinxAtStartPar
10011
&
\sphinxAtStartPar
19
&
\sphinxAtStartPar
Device control three
&
\sphinxAtStartPar
111110
&
\sphinxAtStartPar
62
&
\sphinxAtStartPar
\textgreater{}
&
\sphinxAtStartPar
1101001
&
\sphinxAtStartPar
105
&
\sphinxAtStartPar
i
\\
\sphinxhline
\sphinxAtStartPar
10100
&
\sphinxAtStartPar
20
&
\sphinxAtStartPar
Device control four
&
\sphinxAtStartPar
111111
&
\sphinxAtStartPar
63
&
\sphinxAtStartPar
?
&
\sphinxAtStartPar
1101010
&
\sphinxAtStartPar
106
&
\sphinxAtStartPar
j
\\
\sphinxhline
\sphinxAtStartPar
10101
&
\sphinxAtStartPar
21
&
\sphinxAtStartPar
Negative Acknowledge
&
\sphinxAtStartPar
1000000
&
\sphinxAtStartPar
64
&
\sphinxAtStartPar
@
&
\sphinxAtStartPar
1101011
&
\sphinxAtStartPar
107
&
\sphinxAtStartPar
k
\\
\sphinxhline
\sphinxAtStartPar
10110
&
\sphinxAtStartPar
22
&
\sphinxAtStartPar
Synchronous idle
&
\sphinxAtStartPar
1000001
&
\sphinxAtStartPar
65
&
\sphinxAtStartPar
A
&
\sphinxAtStartPar
1101100
&
\sphinxAtStartPar
108
&
\sphinxAtStartPar
l
\\
\sphinxhline
\sphinxAtStartPar
10111
&
\sphinxAtStartPar
23
&
\sphinxAtStartPar
End of transmission block
&
\sphinxAtStartPar
1000010
&
\sphinxAtStartPar
66
&
\sphinxAtStartPar
B
&
\sphinxAtStartPar
1101101
&
\sphinxAtStartPar
109
&
\sphinxAtStartPar
m
\\
\sphinxhline
\sphinxAtStartPar
11000
&
\sphinxAtStartPar
24
&
\sphinxAtStartPar
Cancel
&
\sphinxAtStartPar
1000011
&
\sphinxAtStartPar
67
&
\sphinxAtStartPar
C
&
\sphinxAtStartPar
1101110
&
\sphinxAtStartPar
110
&
\sphinxAtStartPar
n
\\
\sphinxhline
\sphinxAtStartPar
11001
&
\sphinxAtStartPar
25
&
\sphinxAtStartPar
End of medium
&
\sphinxAtStartPar
1000100
&
\sphinxAtStartPar
68
&
\sphinxAtStartPar
D
&
\sphinxAtStartPar
1101111
&
\sphinxAtStartPar
111
&
\sphinxAtStartPar
o
\\
\sphinxhline
\sphinxAtStartPar
11010
&
\sphinxAtStartPar
26
&
\sphinxAtStartPar
Substitute
&
\sphinxAtStartPar
1000101
&
\sphinxAtStartPar
69
&
\sphinxAtStartPar
E
&
\sphinxAtStartPar
1110000
&
\sphinxAtStartPar
112
&
\sphinxAtStartPar
p
\\
\sphinxhline
\sphinxAtStartPar
11011
&
\sphinxAtStartPar
27
&
\sphinxAtStartPar
Escape
&
\sphinxAtStartPar
1000110
&
\sphinxAtStartPar
70
&
\sphinxAtStartPar
F
&
\sphinxAtStartPar
1110001
&
\sphinxAtStartPar
113
&
\sphinxAtStartPar
q
\\
\sphinxhline
\sphinxAtStartPar
11100
&
\sphinxAtStartPar
28
&
\sphinxAtStartPar
File separator
&
\sphinxAtStartPar
1000111
&
\sphinxAtStartPar
71
&
\sphinxAtStartPar
G
&
\sphinxAtStartPar
1110010
&
\sphinxAtStartPar
114
&
\sphinxAtStartPar
r
\\
\sphinxhline
\sphinxAtStartPar
11101
&
\sphinxAtStartPar
29
&
\sphinxAtStartPar
Group separator
&
\sphinxAtStartPar
1001000
&
\sphinxAtStartPar
72
&
\sphinxAtStartPar
H
&
\sphinxAtStartPar
1110011
&
\sphinxAtStartPar
115
&
\sphinxAtStartPar
s
\\
\sphinxhline
\sphinxAtStartPar
11110
&
\sphinxAtStartPar
30
&
\sphinxAtStartPar
Record separator
&
\sphinxAtStartPar
1001001
&
\sphinxAtStartPar
73
&
\sphinxAtStartPar
I
&
\sphinxAtStartPar
1110100
&
\sphinxAtStartPar
116
&
\sphinxAtStartPar
t
\\
\sphinxhline
\sphinxAtStartPar
11111
&
\sphinxAtStartPar
31
&
\sphinxAtStartPar
Unit separator
&
\sphinxAtStartPar
1001010
&
\sphinxAtStartPar
74
&
\sphinxAtStartPar
J
&
\sphinxAtStartPar
1110101
&
\sphinxAtStartPar
117
&
\sphinxAtStartPar
u
\\
\sphinxhline
\sphinxAtStartPar
100000
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
Space
&
\sphinxAtStartPar
1001011
&
\sphinxAtStartPar
75
&
\sphinxAtStartPar
K
&
\sphinxAtStartPar
1110110
&
\sphinxAtStartPar
118
&
\sphinxAtStartPar
v
\\
\sphinxhline
\sphinxAtStartPar
100001
&
\sphinxAtStartPar
33
&
\sphinxAtStartPar
!
&
\sphinxAtStartPar
1001100
&
\sphinxAtStartPar
76
&
\sphinxAtStartPar
L
&
\sphinxAtStartPar
1110111
&
\sphinxAtStartPar
119
&
\sphinxAtStartPar
w
\\
\sphinxhline
\sphinxAtStartPar
100010
&
\sphinxAtStartPar
34
&
\sphinxAtStartPar
“
&
\sphinxAtStartPar
1001101
&
\sphinxAtStartPar
77
&
\sphinxAtStartPar
M
&
\sphinxAtStartPar
1111000
&
\sphinxAtStartPar
120
&
\sphinxAtStartPar
x
\\
\sphinxhline
\sphinxAtStartPar
100011
&
\sphinxAtStartPar
35
&
\sphinxAtStartPar
\#
&
\sphinxAtStartPar
1001110
&
\sphinxAtStartPar
78
&
\sphinxAtStartPar
N
&
\sphinxAtStartPar
1111001
&
\sphinxAtStartPar
121
&
\sphinxAtStartPar
y
\\
\sphinxhline
\sphinxAtStartPar
100100
&
\sphinxAtStartPar
36
&
\sphinxAtStartPar
\$
&
\sphinxAtStartPar
1001111
&
\sphinxAtStartPar
79
&
\sphinxAtStartPar
O
&
\sphinxAtStartPar
1111010
&
\sphinxAtStartPar
122
&
\sphinxAtStartPar
z
\\
\sphinxhline
\sphinxAtStartPar
100101
&
\sphinxAtStartPar
37
&
\sphinxAtStartPar
\%
&
\sphinxAtStartPar
1010000
&
\sphinxAtStartPar
80
&
\sphinxAtStartPar
P
&
\sphinxAtStartPar
1111011
&
\sphinxAtStartPar
123
&
\sphinxAtStartPar
\{
\\
\sphinxhline
\sphinxAtStartPar
100110
&
\sphinxAtStartPar
38
&
\sphinxAtStartPar
\&
&
\sphinxAtStartPar
1010001
&
\sphinxAtStartPar
81
&
\sphinxAtStartPar
Q
&
\sphinxAtStartPar
1111100
&
\sphinxAtStartPar
124
&
\sphinxAtStartPar
|
\\
\sphinxhline
\sphinxAtStartPar
100111
&
\sphinxAtStartPar
39
&
\sphinxAtStartPar
‘
&
\sphinxAtStartPar
1010010
&
\sphinxAtStartPar
82
&
\sphinxAtStartPar
R
&
\sphinxAtStartPar
1111101
&
\sphinxAtStartPar
125
&
\sphinxAtStartPar
\}
\\
\sphinxhline
\sphinxAtStartPar
101000
&
\sphinxAtStartPar
40
&
\sphinxAtStartPar
(
&
\sphinxAtStartPar
1010011
&
\sphinxAtStartPar
83
&
\sphinxAtStartPar
S
&
\sphinxAtStartPar
1111110
&
\sphinxAtStartPar
126
&
\sphinxAtStartPar
\textasciitilde{}
\\
\sphinxhline
\sphinxAtStartPar
101001
&
\sphinxAtStartPar
41
&
\sphinxAtStartPar
)
&
\sphinxAtStartPar
1010100
&
\sphinxAtStartPar
84
&
\sphinxAtStartPar
T
&
\sphinxAtStartPar
1111111
&
\sphinxAtStartPar
127
&
\sphinxAtStartPar
Delete
\\
\sphinxhline
\sphinxAtStartPar
101010
&
\sphinxAtStartPar
42
&
\sphinxAtStartPar
*
&
\sphinxAtStartPar
1010101
&
\sphinxAtStartPar
85
&
\sphinxAtStartPar
U
&&&\\
\sphinxbottomrule
\end{longtable}
\sphinxtableafterendhook
\sphinxatlongtableend
\end{savenotes}

\sphinxstepscope


\subsubsection{None/Null and Some}
\label{\detokenize{chapters/programming_fundamentals/none_some:none-null-and-some}}\label{\detokenize{chapters/programming_fundamentals/none_some::doc}}
\sphinxAtStartPar
Many programming languages, but not all, have a data type of \sphinxcode{\sphinxupquote{%
\PYG{k+kc}{None}%
}}. This is the equivalent of \sphinxstyleemphasis{blank} entry. We might have code along the lines of

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exam\PYGZus{}mark} \PYG{o}{=} \PYG{k+kc}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
because we’ve not got the exam mark available yet. The blank may be filled in later in the code. It’s useful to set data to \sphinxcode{\sphinxupquote{%
\PYG{k+kc}{None}%
}} if we don’t have it yet, because we can then check, for example at the end of the code. Any students who have \sphinxcode{\sphinxupquote{%
\PYG{k+kc}{None}%
}} as their exam mark didn’t sit the exam. (Or there’s any error in our code!)

\sphinxAtStartPar
In C/C++ \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{NULL}%
}} is used to the same effect.

\sphinxAtStartPar
Rust introduces a \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Some}%
}} type. This lets you check that you have got something, without necessarily caring what it is at that point in time. It might be an integer, or a string or something else. \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Some}%
}} just lets you represent that you have something present. This can be very helpful when you have multiple data types that a function might work with.

\sphinxstepscope


\subsubsection{Datetimes}
\label{\detokenize{chapters/programming_fundamentals/datetimes:datetimes}}\label{\detokenize{chapters/programming_fundamentals/datetimes::doc}}
\sphinxAtStartPar
It’s very common that we want to represent dates and times in our programs.

\sphinxAtStartPar
Dates and times have a particular format that humans understand: days, weeks, months, years; hours, minutes, seconds; there are different time zones around the world, and so on. They add in multiples of 60 for seconds and minutes, 24 for hours, 7 for days, and 28/29/30/31 for weeks, 12 for months, and so on.

\sphinxAtStartPar
They also have potentially quite complicated rules around how they work. For example, they also don’t necessarily add/subtract in the same way was normal numbers: 6pm plus 8 hours is 2am, the next day, not 14pm. (Even this isn’t always true: due to daylight savings we put the clocks forwards/back twice a year, which would lead to a different result.)

\sphinxAtStartPar
To allow for this, there are special data types for storing dates and times. There are then lots of functions for manipulating these, such as correctly adding a number of hours to a given time. We won’t cover all of these here, but you might want to remember there are lots of functions avaiable for helping to work with dates and times.

\sphinxAtStartPar
Briefly, as a Python example, the commands below will make a variable \sphinxcode{\sphinxupquote{%
\PYG{n}{x}%
}} of type datetime. It will contain the date time of whenever the code is run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{datetime}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Dataframes}
\label{\detokenize{chapters/programming_fundamentals/dataframes:dataframes}}\label{\detokenize{chapters/programming_fundamentals/dataframes::doc}}
\sphinxAtStartPar
Dataframes provide a table\sphinxhyphen{}like environment in order to keep our data (which could have lots of different types). It thus provides a spreadsheet\sphinxhyphen{}like interface for working with data, which can be very helpful. A dataframe can help us organize our data into a common (table/spreadsheet) format without having to go to the effort of defining our own objects, custom data types and so on. They are very commonly used in \sphinxstyleemphasis{data science} and \sphinxstyleemphasis{data visualization} type applications.

\sphinxAtStartPar
A picture of a typical dataframe (here made using the \sphinxhref{https://pola.rs/}{Polars} interface) in Python is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{dataframe_example}.png}
\end{figure}

\sphinxAtStartPar
We won’t consider the details of dataframes in more detail here, we will explore them in the labs instead.

\sphinxAtStartPar
Not every programming languages has the concept of dataframes, and you can always use a 2D list or array or similar in a table\sphinxhyphen{}like structure. Nevertheless, when dataframes are available they provide lots of built in functions to help processing data.


\subsection{Dynamically typed vs. statically typed}
\label{\detokenize{chapters/programming_fundamentals/data_types:dynamically-typed-vs-statically-typed}}
\sphinxAtStartPar
In general, Python is \sphinxstyleemphasis{dynamically typed}. That means, it looks at our code for us, and automatically works out which data type to use and this can change on\sphinxhyphen{}the\sphinxhyphen{}fly. In contrast, Rust is \sphinxstyleemphasis{statically typed}. We have to explicitly say what data type to use for a piece of data. For our purposes, you may see \sphinxstyleemphasis{weakly typed} and \sphinxstyleemphasis{strongly typed} being used in place of dynamic and static.

\sphinxAtStartPar
Being statically typed makes it more work for the programmer, as you have to enter this information each time you define a new variable (and think about what you want the data type to be!). The resulting program can then run faster, as the computer doesn’t have to figure out the data type for you. It can also help avoid mistakes. If you try and put, say, text in a variable expecting a number, this is easy for the computer to automatically spot that there’a bug in the code.

\begin{sphinxadmonition}{note}{Aside}

\sphinxAtStartPar
While dynamically typed, Python has the concept of \sphinxstyleemphasis{type hints}. When we make a variable, we can state the data type we think it should have, in addition to giving the name and the value of the variable. The example as we had in {\hyperref[\detokenize{chapters/programming_fundamentals/variables:single-variables}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{variables}}}}} might now look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{pi\PYGZus{}ish}\PYG{p}{:} \PYG{n+nb}{float} \PYG{o}{=} \PYG{l+m+mf}{3.1415}
\PYG{n}{name}\PYG{p}{:} \PYG{n+nb}{str} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alex}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{check}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{blank}\PYG{p}{:} \PYG{k+kc}{None} \PYG{o}{=} \PYG{k+kc}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly for functions, you can add \sphinxcode{\sphinxupquote{%
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}%
}} to flag the data type of the function output. Our example from {\hyperref[\detokenize{chapters/programming_fundamentals/functions:functions}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{functions}}}}} might now look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{float}\PYG{p}{:}
     \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}
     \PYG{k}{return} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{%
\PYG{n}{a}\PYG{p}{:} \PYG{n+nb}{int}%
}} indicates that it’s expecting input \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}} to be an integer. In contrast, input \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} is expected to be a float.
\sphinxcode{\sphinxupquote{%
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{float}%
}} indicates that the output, \sphinxcode{\sphinxupquote{%
\PYG{n}{c}%
}} in this case, should be a floating point number.

\sphinxAtStartPar
These \sphinxstyleemphasis{hints} are intended for programmers looking at or using the code. Particularly for large code bases or multi\sphinxhyphen{}developer teams, they can help people understand the code and use it correctly. There are also automatic tools which can flag if there is a conflict in the types being hinted at.

\sphinxAtStartPar
As this is an introductory course, we won’t look at, or enforce, type hinting any further beyond this aside. For Python coding however, it is generally considered good practice to include type hints in your code.
\end{sphinxadmonition}

\sphinxstepscope


\section{Conditionals and loops}
\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:conditionals-and-loops}}\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops::doc}}
\sphinxAtStartPar
Once you have data, stored in a variable or an object, and ways to manipulate or modify or interact with that data via functions or methods, the main art of programming is plumbing together the different steps that are needed in order to achieve the required overall functionality. There are several more common programming concepts to help you achieve this.


\subsection{If/else statements}
\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:if-else-statements}}
\sphinxAtStartPar
If/else statements allow you to execute code only if certain conditions are met. For example, the code below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{n}{a}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{k}{elif} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
will set the value of \sphinxcode{\sphinxupquote{%
\PYG{n}{c}%
}} differently depending on the values of \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}}. Here there are only three branches, but there could be as many as you want.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{%
\PYG{k}{else}%
}} case acts as catch all, the default if none of the other conditions match. You can use this to help catch error cases. For example, you might re\sphinxhyphen{}write the above code more like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{k}{if} \PYG{n}{b} \PYG{o}{==} \PYG{n}{a}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{k}{elif} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
\PYG{k}{elif} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Something must have gone wrong!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{For loops}
\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:for-loops}}\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:id1}}
\sphinxAtStartPar
It’s very common that we want to perform the same operation multiple times. For example, maybe we want to load all of the marks that a student has obtained across the labs and sum them. We need to loop through the marks for each lab and add them to a running total.

\sphinxAtStartPar
We’ll start with an example of a loop using the C programming language, as it helps illustrate the operation. Here, the basic syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{start\PYGZus{}condition}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{end\PYGZus{}condition}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{step}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// statements to run}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
such that an overall loop might look like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define N 10}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{total\PYGZus{}mark}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{total\PYGZus{}mark}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{total\PYGZus{}mark}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} is the \sphinxstyleemphasis{loop variable}, the variable used to keep track of which iteration of the loop we are on. Here is it called \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}}, but we can use any valid variable name. The first time the for loop is run, \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} is set to 0. The second argument, \sphinxcode{\sphinxupquote{%
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}%
}}, gives the control statement. The loop will continue to execute while this statement is true. Note that here \sphinxcode{\sphinxupquote{%
\PYG{n}{N}%
}} is 10, and must match the number of entries in lab\_marks or you’ll get bugs when the program runs. The third argument, \sphinxcode{\sphinxupquote{%
\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}%
}}, gives the equation for modifying the loop variable at the end of each iteration. \sphinxcode{\sphinxupquote{%
\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}%
}} means \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} increases by 1 each time, so the code looks at \sphinxcode{\sphinxupquote{%
\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}}, then \sphinxcode{\sphinxupquote{%
\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}%
}}, and so on.

\sphinxAtStartPar
The above works well, and is very common. The main limitation is that you the programmer have to know how many entries are present in the array. In the above example we hard coded it to be 10. If we added or removed another lab, the code would have to change. (Indeed in this example the code would have to change in two places: the value of \sphinxcode{\sphinxupquote{%
\PYG{n}{N}%
}} on line 1, and the number of entries in \sphinxcode{\sphinxupquote{%
\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]}%
}} on line 2.).

\sphinxAtStartPar
Wanting to work with all of the elements that are stored is such a common thing to do that many other languages provide an improved syntax which means you don’t need to look up how many entries are present. They use \sphinxstyleemphasis{iterators} to automatically makes the start/stop/step conditions for us. The same loop in Python would look more like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lab\PYGZus{}marks} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{mark} \PYG{o+ow}{in} \PYG{n}{lab\PYGZus{}marks}\PYG{p}{:}
    \PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{n}{total\PYGZus{}mark} \PYG{o}{+} \PYG{n}{mark}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note that Python also provides a \sphinxcode{\sphinxupquote{%
\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}%
}} method that we could have used in this case rather than writing our own code.)

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n}{mark}%
}} is set in turn to \sphinxcode{\sphinxupquote{%
\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}%
}} and so on. We won’t go into the details of \sphinxstyleemphasis{iterators}, most objects we’ll work with already make them for us. They simplify writing the loop as we don’t need to count ourselves how many entries are present.

\sphinxAtStartPar
Note that if you need to keep track of how many times the loop has run, you can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lab\PYGZus{}marks} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{mark} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lab\PYGZus{}marks}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{n}{total\PYGZus{}mark} \PYG{o}{+} \PYG{n}{mark}
\end{sphinxVerbatim}

\sphinxAtStartPar
to provide a variable \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}}, like we had in the first C example.


\subsection{While loops}
\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:while-loops}}
\sphinxAtStartPar
While loops operate in a similar manner. The code in the loop runs multiple times, until some condition is no longer met. For example, we might write the above example as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lab\PYGZus{}marks} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lab\PYGZus{}marks}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{total\PYGZus{}mark} \PYG{o}{=} \PYG{n}{total\PYGZus{}mark} \PYG{o}{+} \PYG{n}{lab\PYGZus{}marks}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general we can accomplish the same functionality using either a for loop or a while loop, they just need writing in slightly different ways.

\sphinxAtStartPar
There’s thus some aspect of style/preference for which you use. While loops tend to be used when waiting for an operation to complete or a user to provide some input. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n}{button\PYGZus{}pressed}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}operation}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Breaking loops}
\label{\detokenize{chapters/programming_fundamentals/conditionals_and_loops:breaking-loops}}
\sphinxAtStartPar
There are many more functions/possible actions to customize the operation of conditional statements and loops.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{pass}%
}} can be used if you don’t want any operation to take place. (Maybe you’ve not implemented that code yet, or there’s a case where no action is needed, but it’s simpler to still have the code checking for such a case being present.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{continue}%
}} in a for or while or loop will stop the execution of the current iteration, and jump to the next one. That is, if \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} was 7, it would straight way change it to 8 and jump back to the top of the loop.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{k}{break}%
}} causes the if statement or for/while loop to stop. The program execution will jump put of the loop and then keep going with whatever comes next.

\end{itemize}

\sphinxAtStartPar
There are lots of variations on the above, and the precise syntax differs between different programming languages, but essentially all have the same basic underlying concepts. We’ll practice these in the labs.

\sphinxstepscope


\section{Scope and namespaces}
\label{\detokenize{chapters/programming_fundamentals/scope:scope-and-namespaces}}\label{\detokenize{chapters/programming_fundamentals/scope:scope}}\label{\detokenize{chapters/programming_fundamentals/scope::doc}}
\sphinxAtStartPar
Our programs will contain a range of data and functions. Best practice is that these have a defined \sphinxstyleemphasis{scope} for where they can be seen and used. That is, a function can only use data that it in its scope \sphinxhyphen{} data that it’s been given access to.

\sphinxAtStartPar
We don’t want all of our data and functions to be available everywhere: it’s bad practice from a security point of view, and can lead to data accidentally being changed. Say you have a variable \sphinxcode{\sphinxupquote{%
\PYG{n}{x1}%
}} in one part of the code, and \sphinxcode{\sphinxupquote{%
\PYG{n}{x2}%
}} in another part of the code. If these were available everywhere, a single typo, having a \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{2}%
}} instead of a \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{1}%
}} would mean your function was working with the wrong data. Moreover, it’s common that we want to use the same (or same\sphinxhyphen{}ish) names for things in multiple places. Having a local scope lets us do this, re\sphinxhyphen{}using variable names without different functions or parts of the program interfering with each other.


\subsection{Scope}
\label{\detokenize{chapters/programming_fundamentals/scope:id1}}
\sphinxAtStartPar
In most programming languages a scope block is defined by curly brackets \sphinxcode{\sphinxupquote{%
\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}%
}}. In Python it’s defined by indented white space (usually 4 spaces). To give a Python example, the below has two functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
    \PYG{k}{return} \PYG{n}{c}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}substract}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}
    \PYG{k}{return} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both of these use the same variable names internally, and that’s completely fine because the variables are \sphinxstyleemphasis{local} to each function. When the function finishes running, the variables go \sphinxstyleemphasis{out of scope} and are no longer accessible.

\sphinxAtStartPar
So, say you had the code

\fvset{hllines={, 5,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
What is the value of \sphinxcode{\sphinxupquote{%
\PYG{n}{x}%
}} on line 5? It is \sphinxcode{\sphinxupquote{%
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}%
}}. The function \sphinxcode{\sphinxupquote{%
\PYG{n}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}%
}} runs on line 4, and sets \sphinxcode{\sphinxupquote{%
\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{world}\PYG{l+s+s2}{\PYGZdq{}}%
}}. However, when the function finshes, and the code moves on to line 5, this defintion of \sphinxcode{\sphinxupquote{%
\PYG{n}{x}%
}} goes out of scope, and the earlier definition of \sphinxcode{\sphinxupquote{%
\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}%
}} comes back in to scope.

\sphinxAtStartPar
There is also a \sphinxstyleemphasis{global} scope, which everything in the program can see. In general however, for a function to be able to see and interact with data, the data should be provided as an input to the function (possibly via a {\hyperref[\detokenize{chapters/programming_fundamentals/pointers:pointers}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pointer}}}}}). Any changed data should be provided as an output (again possibly using {\hyperref[\detokenize{chapters/programming_fundamentals/pointers:pointers}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pointers}}}}}).


\subsection{Namespaces}
\label{\detokenize{chapters/programming_fundamentals/scope:namespaces}}
\sphinxAtStartPar
\sphinxstyleemphasis{Namespaces} help us to re\sphinxhyphen{}use function names in different parts of a program. Apart from a few core parts of a programming language, and functions we’ve made ourselves in the same code file, functions have to explicitly be brought into scope in order for our program to be able to see and use them.

\sphinxAtStartPar
In Python this is done with \sphinxcode{\sphinxupquote{%
\PYG{k+kn}{import}%
}}. Rust has \sphinxcode{\sphinxupquote{%
\PYG{k}{use}%
}}. For example, in Python it’s common to have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{numpy}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{np}
\end{sphinxVerbatim}

\sphinxAtStartPar
This brings the {\hyperref[\detokenize{chapters/software_development_tools/libraries:libraries}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{library}}}}} \sphinxcode{\sphinxupquote{%
\PYG{n}{numpy}%
}} into scope, and gives it the shorter name \sphinxcode{\sphinxupquote{%
\PYG{n}{np}%
}}. Numpy is commonly used in engineering tasks and we’ll see it in the labs. It provides a function sum. We access this as \sphinxcode{\sphinxupquote{%
\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}%
}} rather than just \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{)}%
}}. Just \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{)}%
}} is a valid Python command, but is different to \sphinxcode{\sphinxupquote{%
\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}%
}}. Having the namespace \sphinxcode{\sphinxupquote{%
\PYG{n}{np}\PYG{o}{.}%
}} helps make it explicit which function we want to use. You can think of the namespace as giving an \sphinxstyleemphasis{address} of which function to use.

\sphinxAtStartPar
In languages other than Python it’s common to use two colons \sphinxcode{\sphinxupquote{%
\PYG{p}{:}\PYG{p}{:}%
}} to separate steps in the namespace. For example, you might have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use}\PYG{+w}{ }\PYG{n}{std}\PYG{p}{::}\PYG{n}{io}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In Rust, this brings a wide number of input/output functions, which are part of the {\hyperref[\detokenize{chapters/software_development_tools/libraries:standard-library}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{standard library}}}}}, into scope.

\sphinxstepscope


\section{Error handling (asserts and exceptions)}
\label{\detokenize{chapters/programming_fundamentals/asserts_and_exceptions:error-handling-asserts-and-exceptions}}\label{\detokenize{chapters/programming_fundamentals/asserts_and_exceptions::doc}}

\subsection{Assert statements}
\label{\detokenize{chapters/programming_fundamentals/asserts_and_exceptions:assert-statements}}
\sphinxAtStartPar
We’ve discussed automated testing (unit and integration testing) {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:automated-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{previously}}}}} but didn’t go into how these are actually carried out.

\sphinxAtStartPar
The basic building block for automated testing is an \sphinxstyleemphasis{assert} statement. This might look something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
This assert statement means \sphinxstyleemphasis{at this point I the programmer know x should be 0. If it is, carry on as usual. If it’s not, flag that the test has failed}.

\sphinxAtStartPar
There are lots of different types of assert checks that can be use. Generally they rely on you the programmer having some knowledge (for your given test input) of what the code should ideally be doing at a particular point.

\sphinxAtStartPar
Assert statements are for you the programmer, letting you test the code. They are not intended for displaying errors to users. It’s possible, for example, to automatically turn assert statements off. That is, they are still in the code, the code remains unedited, but they are just ignored when the code runs. They thus don’t have any performance impact. It’s possible to run code in \sphinxstyleemphasis{debug} mode, or in \sphinxstyleemphasis{deployment mode} by changing some settings which change how much optimization is performed behind the scenes.

\sphinxAtStartPar
If you run a Python program \sphinxcode{\sphinxupquote{%
\PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py}%
}} from the command line, rather than using a GUI, usually you would start it with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python3 my\PYGZus{}script.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you add the optional \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZhy{}O}%
}}, all debug and assert statements will be ignored, probably making the code run faster.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} python3 \PYGZhy{}O my\PYGZus{}script.py}
\end{sphinxVerbatim}

\sphinxAtStartPar
Adding \sphinxcode{\sphinxupquote{%
\PYG{g+go}{\PYGZhy{}OO}%
}} will perform even more optimizations.


\subsection{Exceptions}
\label{\detokenize{chapters/programming_fundamentals/asserts_and_exceptions:exceptions}}
\sphinxAtStartPar
For displaying errors to users \sphinxstyleemphasis{exceptions} are used (or their equivalent \sphinxhyphen{} not all languages use the same term or approach here).

\sphinxAtStartPar
You can \sphinxstyleemphasis{raise} an exception directly, for example as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a number larger than 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{inp} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} pauses and gets input from the keyboard}
\PYG{n}{inp\PYGZus{}int} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{inp}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} converts the input to an integer}

\PYG{k}{if} \PYG{n}{inp\PYGZus{}int} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error! The number you entered was less than 0.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here it’s very directly an error by the user that’s being checked, and so this is handled via an exception. This will present an error message to the user, in red, and you can add information to help the reader understand what went wrong.

\sphinxAtStartPar
Commonly the above Python syntax isn’t used directly. \sphinxstyleemphasis{try\sphinxhyphen{}except} (also known as \sphinxstyleemphasis{try\sphinxhyphen{}catch}) blocks are used. These \sphinxstyleemphasis{try} to do the commands given, and if they don’t work raise the following error. An example is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fn} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{file.txt}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{try}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} If file fn already exits, open it in \PYGZsq{}append\PYGZsq{} mode. That this, to add text on at the end of the existing file}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{fn}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{FileNotFoundError}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} If an error occurs, make a new file and write in this blank file}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{fn}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{world}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above is an example of a \sphinxstyleemphasis{recoverable} error. If the file to use doesn’t exist, it switches to making a new file instead. You can also have \sphinxstyleemphasis{unrecoverable} errors, where it’s not meaningful for the program to keep going. Here the program just needs to stop (first closing any open files, or network connections, or similar) and then pass an error message to the user.

\sphinxAtStartPar
Rust separates between \sphinxstyleemphasis{recoverable} and \sphinxstyleemphasis{unrecoverable} errors more than Python does. It has a dedicated error handling data type \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Result}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{E}\PYG{o}{\PYGZgt{}}%
}}. This gives an object, which contains the successful output, \sphinxcode{\sphinxupquote{%
\PYG{n}{T}%
}} here; and any errors produced, called \sphinxcode{\sphinxupquote{%
\PYG{n}{E}%
}} here. You can then check whether the result was \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Ok}%
}} in which case you perform one action, or whether the result contained an error, in which case you carry out a different action. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{let}\PYG{+w}{ }\PYG{n}{file\PYGZus{}result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{File}\PYG{p}{::}\PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kd}{let}\PYG{+w}{ }\PYG{n}{file}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{match}\PYG{+w}{ }\PYG{n}{file\PYGZus{}result}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n+nb}{Ok}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{file}\PYG{p}{,}
\PYG{+w}{    }\PYG{n+nb}{Err}\PYG{p}{(}\PYG{n}{error}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n+nf+fm}{panic!}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening the file: \PYGZob{}error:?\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the aim is to set \sphinxcode{\sphinxupquote{%
\PYG{n}{file}%
}} to be the opened \sphinxcode{\sphinxupquote{%
\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}%
}}. Rather than just doing this in a single line of code, to allow us to check for errors (such as the file not existing) \sphinxcode{\sphinxupquote{%
\PYG{n}{File}\PYG{p}{::}\PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}%
}} returns a \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Result}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}%
}} data type into an intermediate variable called \sphinxcode{\sphinxupquote{%
\PYG{n}{file\PYGZus{}result}%
}}. There is then a \sphinxcode{\sphinxupquote{%
\PYG{k}{match}%
}} function. If the contents of \sphinxcode{\sphinxupquote{%
\PYG{n}{file\PYGZus{}result}%
}} indicate the operation worked, \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Ok}\PYG{p}{(}\PYG{p}{)}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{n}{file}%
}} is set as was wanted. If they indicate that an error occurred, \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{Err}\PYG{p}{(}\PYG{p}{)}%
}}, \sphinxcode{\sphinxupquote{%
\PYG{n+nf+fm}{panic!}\PYG{p}{(}\PYG{p}{)}%
}} is called. \sphinxcode{\sphinxupquote{%
\PYG{n+nf+fm}{panic!}\PYG{p}{(}\PYG{p}{)}%
}} causes the program to terminate, and in this case display an error message. More generally this gives you a place for any \sphinxstyleemphasis{error handling code} to determine what to do if an error occurs.

\sphinxAtStartPar
It’s up to you as the program designer to decide how much error handling you want to do. This is an important part of the overall program design \sphinxhyphen{} we can’t assume that actions are always successful, particularly when they involve interacting with the outside world. We may want to open a file, but have the filename wrong. We may want to access a resource on the Internet, but our network connection isn’t working. For all of these type of cases you likely want to add some error handling code that the program terminates gracefully rather than just crashing.

\begin{sphinxadmonition}{note}{This course}

\sphinxAtStartPar
We’ll see examples of using this functionality in the labs, particularly when we look at testing.
\end{sphinxadmonition}

\sphinxstepscope


\section{Design patterns}
\label{\detokenize{chapters/programming_fundamentals/design_patterns:design-patterns}}\label{\detokenize{chapters/programming_fundamentals/design_patterns::doc}}
\sphinxAtStartPar
Once you have data, stored in objects and variables, and ways to manipulate data in methods and functions, ways to control the program flow, and ways to handle errors, you fundamentally have what you need to start building up complex programs. In most cases this probably starts by thinking about the data \sphinxhyphen{} how it is best stored, what objects and methods do you want? As we saw when {\hyperref[\detokenize{chapters/programming_fundamentals/objects:objects}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{introducing objects}}}}} you can use the type system to help you avoid making errors.

\sphinxAtStartPar
We also introduced {\hyperref[\detokenize{chapters/software_lifecycle/software_architecture:software-architecture}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{software architecture}}}}} briefly. You do need to \sphinxstyleemphasis{design} a program. In the same way that you wouldn’t build a house without having plans and drawings in advance, it’s extremely hard to write programs with millions of lines of code without some plans and drawings in advance.

\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Unified\_Modeling\_Language}{UML (Unified Modeling Language)} is one widely used approach to visualize a program structure, but goes beyond the scope of this course. We thus won’t say too much about this. A lot in this area comes from gaining hands on experience, and seeing what works and what doesn’t work for your needs. Also, in many cases in practice when starting out you’ll be working on a code base which already exists, improving it and adding features, rather than starting from a blank slate.

\sphinxAtStartPar
However we want to highlight two common \sphinxstyleemphasis{design patterns}, that is, ways of thinking about how the code is structured. These can help you start thinking about how you might structure your code, and you can then go further in your \sphinxhref{https://uom-eee-eeen1xxx2.github.io/chapters/course\_administration/suggested\_reading.html}{further reading} if you desire.


\subsection{Flow charts}
\label{\detokenize{chapters/programming_fundamentals/design_patterns:flow-charts}}
\sphinxAtStartPar
The programming we’re going to look at is known as \sphinxstyleemphasis{imperative} programming. The code execution may jump from place to place as we use different functions and methods, but fundamentally the code executes line by line starting from the top of the code file. This means that flowcharts tend to naturally fit into representing the functionality we need. A simple example flowchart is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{flow_chart}.png}
\end{figure}

\sphinxAtStartPar
This is quite a high level flow chart. You can of course add more details, whether that be steps, or details on what the data looks like at each stage. Most undergraduates are already familiar with flow charts, and so we won’t give more details here other than to note that there is an international standard (ISO 5807) for which shapes should be used in a flow chart.


\subsection{State machines}
\label{\detokenize{chapters/programming_fundamentals/design_patterns:state-machines}}
\sphinxAtStartPar
A second common design pattern, and one which in my experience is overlooked by undergraduates, is \sphinxstyleemphasis{state machines}. (In my experience most undergraduates tend to go straight to flow charts.)

\sphinxAtStartPar
You’ll actually encounter state machines in your digital electronics courses. They are commonly used in the design of digital hardware. They can be just as useful in the design of software.

\sphinxAtStartPar
Here you think about the discrete \sphinxstyleemphasis{states} that program might have, and what triggers the state to change. For example, there might be an \sphinxstyleemphasis{initialization} state where files and similar are loaded. There might be a \sphinxstyleemphasis{wait} state while waiting for some user input or a file to finish downloading. There might also be a \sphinxstyleemphasis{shutdown} state where everything is tidied up before the program terminates. A simple example is shown on the state diagram below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{state_diagram}.png}
\end{figure}

\sphinxAtStartPar
Here \sphinxstyleemphasis{EEG} refers to the data that is being collected in real\sphinxhyphen{}time from a device connected to the computer. SO refers to a specific feature in this data that we want to detect. If an SO is detected, we want to play a fixed number of sounds, after some delays. The system starts in \sphinxstyleemphasis{State 0} and then moves round once an SO is detected. (This is a real example based on some of our previous research code \sphinxhref{https://github.com/ALEX-CASSON-LAB/ClosedLoopSoundStimulationDuringSleepInMatlab}{available here}. Note that this was coded in Matlab rather than in one of the languages we’ll use in this course.)

\sphinxstepscope


\section{Shallow vs. deep copies}
\label{\detokenize{chapters/programming_fundamentals/copies:shallow-vs-deep-copies}}\label{\detokenize{chapters/programming_fundamentals/copies::doc}}
\sphinxAtStartPar
As a last, relatively minor point before some of the more advanced fundamentals, we have a small note about making copies. This doesn’t always give the behavior people are expecting when they are starting out.

\sphinxAtStartPar
If you have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} is a copy of \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}}. However, it is a \sphinxstyleemphasis{shallow copy}. To save space in memory, the entries (0 to 8 in this case) aren’t actually copied. Rather, a new variable \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} is made, and its entries just point to the the original entries in \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}}. This is shown below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{shallow_copy}.png}
\end{figure}

\sphinxAtStartPar
If you then run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
you’ll find that both \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} have updated. However, if you run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} won’t have this added to it. \sphinxcode{\sphinxupquote{%
\PYG{n}{b}%
}} won’t know where any additional locations in \sphinxcode{\sphinxupquote{%
\PYG{n}{a}%
}} from after the copy was made. This use of memory is illustrated in the figure below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{shallow_copy_append}.png}
\end{figure}

\sphinxAtStartPar
This can lead to some confusing behavior if you’re not expecting it!

\sphinxAtStartPar
If you want two completely independent copies of a piece of data you need to make a \sphinxstyleemphasis{deep copy}. In Python this is done with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{copy}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{copy}\PYG{o}{.}\PYG{n}{deepcopy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general deep copies should only be used when you really need them. They will use more memory, and for large items it can take quite a lot of time to actually make a copy of all of the data (rather than just pointing to the data that’s already present).

\sphinxstepscope


\section{Stack and heap memory}
\label{\detokenize{chapters/programming_fundamentals/stack_and_heap:stack-and-heap-memory}}\label{\detokenize{chapters/programming_fundamentals/stack_and_heap:stack-and-heap}}\label{\detokenize{chapters/programming_fundamentals/stack_and_heap::doc}}
\sphinxAtStartPar
As you move to more advanced programming, as we will in the second half of the course when we consider Rust and brief introductions to C/C++ a lot of the focus is on \sphinxstyleemphasis{memory management}. You get high performance code you have to help manually manage the memory that the computer has. We thus need to know a bit about how the memory is organized and accessed.

\sphinxAtStartPar
Inside a computer, memory is divided into two parts: \sphinxstyleemphasis{stack} memory and \sphinxstyleemphasis{heap} memory. These are \sphinxstyleemphasis{software level} concepts, it’s how the computer chooses to organise it’s memory, rather than reflecting how the memory is physically present. These two different types of memory work, and are optimized, in different ways. For lower level programming, such as in C, C++, and Rust, making suitable use of the stack vs. the heap is an important part of programming.


\subsection{Stack memory}
\label{\detokenize{chapters/programming_fundamentals/stack_and_heap:stack-memory}}
\sphinxAtStartPar
When a program starts, typically it is allocated some memory on the stack. Usually a few Megabytes on a desktop/laptop type device. This is enough for getting most programs started, and may be enough for some small programs in their entirity. It’s not enough for putting everything on though, particularly if you’re working with large datasets. It’s not intended to be enough \sphinxhyphen{} it should get you started and then after that you the programmer need to think about the memory management.

\sphinxAtStartPar
Memory in the stack is \sphinxstyleemphasis{contiguous}. That means that all of the memory locations are next to each other, in a stack. It in fact operates as first in, first out buffer. The \sphinxstyleemphasis{stack pointer} stores where the next free memory location is. Each time a new variable (or similar) is made, it’s put on the top of the stack. The computer thus doesn’t have to search for a suitable memory location, it just puts the next item on top of the big pile of items that it already has. Variables on the stack are automatically deleted when they go out of scope, say when a function exits. This is illustrated below.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{stack}.png}
\end{figure}

\begin{sphinxadmonition}{note}{Aside}

\sphinxAtStartPar
Opposite to how the figure above is drawn, the stack usually starts at the top and grows \sphinxstyleemphasis{downwards} in terms of memory addresses. That way, the last address is always 0, no matter how big the overall stack is.
\end{sphinxadmonition}

\sphinxAtStartPar
You can also manually add or remove things to the stack yourself. \sphinxstyleemphasis{Pop} means to remove whatever is at the top of the stack. \sphinxstyleemphasis{Push} is to add an item to the top of stack. Each programming language will have its own commands for doing these.

\sphinxAtStartPar
Stack memory is only visible to your program, the current thread that’s running.

\sphinxAtStartPar
Due to these properties, the stack memory is very quick. You, and the computer, don’t need to think about where to put things in the memory. It just goes in the next available slot.

\sphinxAtStartPar
It comes at the cost of being small in size. (The operating system can’t guarantee to give every program Gigabytes of memory on the stack, you’d quickly run out of memory when running more than one program at the same time.) You can get \sphinxstyleemphasis{stack overflow} errors when the stack runs out of space. You also really need data that is of a fixed size. If the data might change size while the program is running, its hard to move the stack pointer on by the correct amount to point to the next free memory location.


\subsection{Heap memory}
\label{\detokenize{chapters/programming_fundamentals/stack_and_heap:heap-memory}}
\sphinxAtStartPar
In contrast, the heap is a larger memory area that your program can request to use space on, as much as it needs. (The operating system might say no if it’s doesn’t have space, and so programs should check that any request for heap memory was successful, before they try to use it.)

\sphinxAtStartPar
Heap memory is also available to other threads on the computer, and so important to use when writing multi\sphinxhyphen{}threaded programs.

\sphinxAtStartPar
As soon as you move beyond small simple programs in languages such as C, C++, and Rust, you probably want to be working with heap memory. Each language has its own commands for requesting and interacting with heap memory, generally via {\hyperref[\detokenize{chapters/programming_fundamentals/pointers:pointers}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pointers or smart pointers}}}}}. We will see how to do this in the labs.

\sphinxAtStartPar
The disadvantage of heap memory is that it is slow compared to stack memory. For example, there is overhead in searching for available memory space, whereas the stack just uses the next memory location along. Frequent allocation and deallocation of memory can also lead to fragmentation, where things are stored in small, non\sphinxhyphen{}contiguous blocks, and this decreases the performance of getting things from memory. If you want to increase the size of an object, but the next memory location up is already being used to store something else, there can be a lot of overhead in finding a new memory location that’s big enough and moving everything to that location. When feasible, you probably want to avoid dynamically growing items on the heap. Instead, reserve as much memory as you need in advance, or reserve large\sphinxhyphen{}ish (whatever that means for your program size) blocks in advance rather than doing lots of small requests.

\sphinxstepscope


\section{Pointers and smart pointers}
\label{\detokenize{chapters/programming_fundamentals/pointers:pointers-and-smart-pointers}}\label{\detokenize{chapters/programming_fundamentals/pointers:pointers}}\label{\detokenize{chapters/programming_fundamentals/pointers::doc}}
\sphinxAtStartPar
Python doesn’t have pointers, it works a bit differently. You thus won’t meet them until towards the end of the course. For languages such as C/C++ and Rust, pointers are an important part of how the languages can be used to write high performance code. You thus need to have some awareness of what they are, to enable you to go deeper and further in future work.


\subsection{What is a pointer}
\label{\detokenize{chapters/programming_fundamentals/pointers:what-is-a-pointer}}
\sphinxAtStartPar
Understanding pointers relies on you having some understanding of how the memory inside a computer is used. That is, the concept of data being stored at an \sphinxstyleemphasis{address}. This idea of having an address, separate from whatever is kept at the address, makes the concept of pointers much easier to follow.

\sphinxAtStartPar
Like with many storage systems, we don’t just put data into the computer memory anywhere. It’s organized for use to make things easy and efficient to find and to modify. This organization (to a first approximation) is done by the computer and/or operating system for us, largely behind the scenes so we don’t have to remember lots of addresses ourselves. Nevertheless, both the address of a memory location, and the contents of that location, are available to our programs.

\sphinxAtStartPar
The table below shows an example of 8 bit (1 byte) words being stored at a particular address, here with the addresses starting at 0. (Note that if a data item requires more than one byte, the overall address is said to be the address of the first byte used.)


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{25}{50}\X{25}{50}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Address
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Contents (in binary)
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{0}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{01010101}%
}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{1}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{10101010}%
}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{2}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{11111111}%
}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{3}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{00000000}%
}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{...}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{...}%
}}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{n\PYGZhy{}1}%
}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{g+go}{01010111}%
}}
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Normally, with our programs we don’t need to know the address that our data is stored at. Just giving the name of the variable is enough, and the computer will work out the address for us. We never see the internals of which memory location is used. This makes our code easier to write as we don’t need to know about where the computer is storing the data. It can pick whatever is optimal, and we can use a nice human readable name in our code.

\sphinxAtStartPar
Sometimes we do want to know the address of the data. This allows us to manipulate the data at that address, and gives us very precise control over the memory that used by the program. You’ll also see in your digital electronics courses that input/output ports on a microprocessor are \sphinxstyleemphasis{memory mapped}. The input (say) is given an address in memory and we can read from the input by reading from the address of the given memory location.

\sphinxAtStartPar
However, we don’t necessarily want to know the numeric address (\sphinxcode{\sphinxupquote{%
\PYG{g+go}{0}%
}} to \sphinxcode{\sphinxupquote{%
\PYG{g+go}{n\PYGZhy{}1}%
}} in the table above), as this is hard to remember, and will likely be different for different computers depending on what else is in the memory when the program is run.

\sphinxAtStartPar
To overcome this, addresses can be stored in a pointer variable. These pointers let us give a human readable name to an address, to make our code easier to read. It’s important to remember that they are an address, a pointer, to where the actual data is stored, rather than the data itself. A graphical representation of this is below. \sphinxcode{\sphinxupquote{%
\PYG{n}{p}%
}} or \sphinxcode{\sphinxupquote{%
\PYG{o}{\PYGZam{}}\PYG{n}{i}%
}} are variables that store the address. \sphinxcode{\sphinxupquote{%
\PYG{o}{*}\PYG{n}{p}%
}} is whatever is stored in that location.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{pointers}.png}
\end{figure}


\subsection{How to work with raw pointers}
\label{\detokenize{chapters/programming_fundamentals/pointers:how-to-work-with-raw-pointers}}
\sphinxAtStartPar
The general syntax for working with pointers is to use \sphinxcode{\sphinxupquote{%
\PYG{o}{*}%
}} to represent the contents that are being pointed to, and \sphinxcode{\sphinxupquote{%
\PYG{o}{\PYGZam{}}%
}} to represent the address. That is, we can write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and \sphinxcode{\sphinxupquote{%
\PYG{n}{p}%
}} will now \sphinxstyleemphasis{point} to \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}}. The two lines of code below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{o}{*}\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will have exactly the same functionally, because \sphinxcode{\sphinxupquote{%
\PYG{n}{i}%
}} and \sphinxcode{\sphinxupquote{%
\PYG{o}{*}\PYG{n}{p}%
}} are both accessing the same location in the computer memory.

\sphinxAtStartPar
To use an analogy, the figure below shows an example of lecture theatres. These contain numbered seats for individual students to sit in.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{pointer_analogy}.png}
\end{figure}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n}{p}%
}} is the seat number that we’re pointing at. \sphinxcode{\sphinxupquote{%
\PYG{o}{*}\PYG{n}{p}%
}} is the student who is in that seat.


\subsection{Pointer arithmetic}
\label{\detokenize{chapters/programming_fundamentals/pointers:pointer-arithmetic}}
\sphinxAtStartPar
As \sphinxcode{\sphinxupquote{%
\PYG{n}{p}%
}}, or \sphinxcode{\sphinxupquote{%
\PYG{o}{\PYGZam{}}\PYG{n}{i}%
}} in the above are storing addresses, we can perform \sphinxstyleemphasis{pointer arithmetic} to change which memory location we’re looking at. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
is accessing the memory location, one address up from \sphinxcode{\sphinxupquote{%
\PYG{n}{p}%
}}. This is very useful when accessing elements in an array.

\sphinxAtStartPar
In C you can use \sphinxcode{\sphinxupquote{%
\PYG{n}{free}\PYG{p}{(}\PYG{p}{)}%
}} to release the pointer once you’ve finished with it. Other languages have similar, but differently named, commands.


\subsection{Smart pointers}
\label{\detokenize{chapters/programming_fundamentals/pointers:smart-pointers}}\label{\detokenize{chapters/programming_fundamentals/pointers:id1}}
\sphinxAtStartPar
Pointers are extremely important and very useful when writing low level code. As, essentially, everything on a computer is given an address in memory, pointers let you use this address in order to enable lots of advanced functionality.

\sphinxAtStartPar
However, pointers are also a common source of programming errors. To give some examples:
\begin{itemize}
\item {} 
\sphinxAtStartPar
As we’ll learn later, you need to think about the {\hyperref[\detokenize{chapters/programming_fundamentals/lifetimes:lifetimes}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{lifetime}}}}} of a variable or piece of memory. You can have a \sphinxstyleemphasis{dangling pointer} if you’re pointing to a memory location that is no longer being used, and no longer contains valid data.

\item {} 
\sphinxAtStartPar
You can have a \sphinxstyleemphasis{null pointer deference} if you try to use a pointer which doesn’t point to a valid memory location.

\item {} 
\sphinxAtStartPar
You can have a \sphinxstyleemphasis{buffer overflow} if you try and access say \sphinxcode{\sphinxupquote{%
\PYG{o}{*}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{6}\PYG{p}{)}%
}} but this is actually a different variable to \sphinxcode{\sphinxupquote{%
\PYG{o}{*}\PYG{n}{p}%
}} because you’ve mis\sphinxhyphen{}counted how big the item is in memory and have accidentally gone on to the next item. In the lecture theater figure shown above, seat 17 is a perfectly valid seat number to be pointing to, but it’s in the next lecture theatre over. You’ll get a student from a different class if you use this location!

\item {} 
\sphinxAtStartPar
You can also have \sphinxstyleemphasis{memory leaks}, if you don’t deallocate the pointer once you’ve finished with it. That is, rather than freeing up memory when done, you just keep asking for more and more over time.

\end{itemize}

\sphinxAtStartPar
All of these errors can be avoided, but it’s up to you to add suitable checks to your code for these and other pointer errors.

\sphinxAtStartPar
To help overcome this, many languages including Rust and C++ have \sphinxstyleemphasis{smart pointers}. Ideally you would probably only work with raw pointers today when writing C code as it doesn’t support smart pointers. (You can use raw pointers in C++, Rust, and similar, it’s just that they also include smart pointers as tools to help you write error free code.) Indeed, one of the key features of Rust and modern C++ are tools to help you think about the \sphinxstyleemphasis{lifetime} of a resource, such as a piece of memory, to help make sure you use it correctly.

\sphinxAtStartPar
A smart pointer is simply a wrapper around a raw pointer. This wrapper includes additional functions that help make sure the pointer is always used correctly.

\sphinxAtStartPar
Here we’ll use a C++ example to demonstrate this. You could make a raw pointer, to point to an integer as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{// Using a raw pointer \PYGZhy{}\PYGZhy{} not recommended}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Code goes here}
\PYG{c+c1}{// ...}

\PYG{c+c1}{// Delete the pointer to free up memory when finished with it}
\PYG{k}{delete}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here it’s up to you the programmer to remember to delete \sphinxcode{\sphinxupquote{%
\PYG{n}{ptr}%
}} once you no longer need it. Otherwise you have a \sphinxstyleemphasis{memory leak}. That is, you risk your program using more and more memory over time (until it eventually crashes) as you’re claiming memory each time the function is called, but not releasing it once you’ve finished using it. It can be hard to spot memory leaks. For example, say the code was now

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{// Using a raw pointer \PYGZhy{}\PYGZhy{} not recommended}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}

\PYG{c+c1}{// Code goes here}
\PYG{c+c1}{// ...}

\PYG{c+c1}{// Then have a check}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// causes the function to exit}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Delete the pointer to free up memory when finished with it}
\PYG{k}{delete}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{%
\PYG{k}{return}%
}} command in the if statement causes the function to stop, in this case if \sphinxcode{\sphinxupquote{%
\PYG{n}{x}%
}} is 0. However, this will mean the \sphinxcode{\sphinxupquote{%
\PYG{k}{delete}\PYG{+w}{ }\PYG{n}{ptr}%
}} line never runs! You remembered to delete the pointer at the end of the function, but not for every possible case in the code and so there’s still a potential memory leak present.

\sphinxAtStartPar
Smart pointers will automatically check and delete the pointer for you when its no longer needed (it goes \sphinxstyleemphasis{out of scope}). In C++ there are several ways of making a smart pointer, with different properties. \sphinxcode{\sphinxupquote{%
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}%
}} is for when you only have one pointer to a piece of memory. The above example could be written as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{my\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prt}\PYG{p}{(}\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}

\PYG{c+c1}{// Code goes here}
\PYG{c+c1}{// ...}

\PYG{c+c1}{// Then have a check}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You, the programmer, don’t have to remember to do all of the pointer management by hand. The code above won’t have a memory leak, as the smart pointer will automatically delete the pointer for you when the function finishes.

\sphinxAtStartPar
The general rule of thumb would be to always use a smart pointer if you can, rather than a raw pointer. They just help you avoid common pointer errors.

\sphinxstepscope


\section{Lifetimes, borrowing, and “modern” approaches}
\label{\detokenize{chapters/programming_fundamentals/lifetimes:lifetimes-borrowing-and-modern-approaches}}\label{\detokenize{chapters/programming_fundamentals/lifetimes:lifetimes}}\label{\detokenize{chapters/programming_fundamentals/lifetimes::doc}}
\sphinxAtStartPar
As we mentioned in {\hyperref[\detokenize{chapters/programming_fundamentals/pointers:pointers}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{pointers}}}}}, when writing low level code we need to think about the \sphinxstyleemphasis{lifetime} of the items we’re working with.

\sphinxAtStartPar
If we open a file, we need to remember to close it when we’re done. Once it’s been closed, we then can’t read from the file again. If we try to read from a closed file, we’ll get an error. If we don’t close the file, we’ll accumulate more and more baggage as the program runs until we eventually run out of resources on the computer.

\sphinxAtStartPar
If we use a section of memory, we need to remember to give it back when we’re done. Once we’ve given it back, we then can’t read from it again. Once we’ve given memory back, it might be used for some other purpose. If we try to read the same memory location again, the read will likely work \sphinxhyphen{} it is still a valid memory location \sphinxhyphen{} but if another program is now using that location we’ll get incorrect data coming back.

\sphinxAtStartPar
This sort of, using a resource, giving it back when we’re done, then remembering we don’t have it any more and so can’t use it, is quite common. It might be using a chunk of memory, a network resource, or something else. In general it’s up to us to think about the lifetime of a resource and when we can validly use it. Making mistakes with this are some of the most common programming errors.

\sphinxAtStartPar
Sometimes, and particularly in Rust programming, we refer to \sphinxstyleemphasis{borrowing} a resource. Rust includes a \sphinxstyleemphasis{borrow checker} to help make sure that if we borrow something, we give it back too.

\sphinxAtStartPar
In general, in older programming languages such as C, freeing up resources once finished with is up to the programmer. You have to include explicit code to do this. More modern languages do this for you. {\hyperref[\detokenize{chapters/programming_fundamentals/pointers:smart-pointers}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{Smart pointers}}}}} were an example of this. Actually, there are many examples. In Python we open a file using the \sphinxcode{\sphinxupquote{%
\PYG{k}{with}%
}} command as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fn} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filename.txt}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{fn}\PYG{p}{)} \PYG{k}{as} \PYG{n}{my\PYGZus{}file}\PYG{p}{:}
    \PYG{n}{my\PYGZus{}file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will automatically close the file for us when it’s finished with. Python does have a \sphinxcode{\sphinxupquote{%
\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}%
}} command, but we don’t need to explicitly include it in our code.

\sphinxAtStartPar
Some people argue, with good merit, that when starting programming we should teach you to write more explicit code so that you get used to opening and closing resources. So, using \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{open}\PYG{p}{(}\PYG{p}{)}%
}} and following it by \sphinxcode{\sphinxupquote{%
\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}%
}}. Or, if using raw pointers in C++, making a pointer \sphinxcode{\sphinxupquote{%
\PYG{k+kt}{int}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)}\PYG{p}{;}%
}} and then deleting it when done with \sphinxcode{\sphinxupquote{%
\PYG{k}{delete}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{;}%
}}.

\sphinxAtStartPar
That’s not the philosophy this course takes. Features have been added to programming languages to stop people from making these common mistakes, and so we’re going to teach you to use them. It’s important though that you don’t forget that this is the computer doing some tasks for you. If you borrow a resource, you always need to remember to give it back. If you’re not doing this explicitly, make sure the computer is doing it for you.

\sphinxAtStartPar
The slight exception to the above is C++. This is both a relatively old programming language, and a modern language. You may hear people refer to \sphinxstyleemphasis{modern} C++. This means using features such as smart pointers, which weren’t available when the language was first introduced in 1985. C++ is updated today every three years. There’s no hard rule, but \sphinxstyleemphasis{modern} C++ generally refers to using C++11, introduced in 2011, or later.

\sphinxAtStartPar
Modern C++ has a wide number of features, such as smart pointers, \sphinxstyleemphasis{containers}, and \sphinxstyleemphasis{templates} to help avoid previously common programming errors. \sphinxstyleemphasis{Resource Acquisition is Initialization (RAII)} is an important part of modern C++. Again, this refers to the concept that if you borrow a resource, you must give it back. RAII approaches automatically give the resource back to the computer when the block of code goes out of {\hyperref[\detokenize{chapters/programming_fundamentals/scope:scope}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{scope}}}}}.

\sphinxstepscope


\section{More advanced topics}
\label{\detokenize{chapters/programming_fundamentals/advanced_topics:more-advanced-topics}}\label{\detokenize{chapters/programming_fundamentals/advanced_topics::doc}}
\sphinxAtStartPar
This is an introductory course on programming and software development. It’s designed to take 200 hours to complete. Some people spend their entire careers on programming and software development! By the time you’ve spent several years programming you’ll know a lot more than we cover in this course. We can’t possibly cover everything, or give you the same depth of experience that just spending several years focused on this topic, working with experienced developers to discuss ideas, options, and alternatives, will give you.

\sphinxAtStartPar
There are a wide number of more advanced topics that we don’t go into. Nevertheless, we briefly list a few of the more common ones below, ones which you are more likely to encounter.


\subsection{Line endings}
\label{\detokenize{chapters/programming_fundamentals/advanced_topics:line-endings}}
\sphinxAtStartPar
In these notes we’ve discussed {\hyperref[\detokenize{chapters/computer_software/major_operating_systems:operating-systems}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{major operating systems}}}}}, and {\hyperref[\detokenize{chapters/programming_fundamentals/text_encoding:ascii}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{ASCII text encoding}}}}}. The different major operating systems make difference choices for how to use these to represent a new line. macOS and Linux use Line Feed (symbol 10), while Windows uses both Carriage Return (symbol 13) and Line Feed (symbol 10), sometimes represented as CRLF. This incompatibility can lead to plain text files not displaying correctly if they were made on one operating system and opened on another.

\sphinxAtStartPar
VSCode in fact displays which line endings it’s using, as shown in the figure below. Here it’s using LF for Linux compatibility. If you click on the LF, VSCode will present the operation to change which line endings are used.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{line_endings}.png}
\end{figure}

\sphinxAtStartPar
If you get a code file which doesn’t look to be displaying correctly, you may want to try changing the line endings used to see whether it fixes the issue.


\subsection{Anonymous functions}
\label{\detokenize{chapters/programming_fundamentals/advanced_topics:anonymous-functions}}
\sphinxAtStartPar
When we discussed functions, they always had a \sphinxstyleemphasis{signature} line giving the same of the function and the inputs. For example, we had

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} is the function name. An anonymous function is when we make a function which isn’t given a name when we first define it. Sometimes these are also known as \sphinxstyleemphasis{lambdas} because many programming languages use the keyword \sphinxcode{\sphinxupquote{%
\PYG{k}{lambda}%
}} to define an anonymous function.

\sphinxAtStartPar
In Python, an anonymous function, implementing the same as \sphinxcode{\sphinxupquote{%
\PYG{n}{add\PYGZus{}and\PYGZus{}multiply}%
}} would be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{p}{:} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Rather than giving the function a name, we’ve stored it in variable \sphinxcode{\sphinxupquote{%
\PYG{n}{x}%
}}.

\sphinxAtStartPar
We won’t make use of anonymous functions in this course. They are useful, for example, if you want to pass a function into another function as an input.


\subsection{Decorators}
\label{\detokenize{chapters/programming_fundamentals/advanced_topics:decorators}}
\sphinxAtStartPar
\sphinxstyleemphasis{Decorators} are items that go around an existing function, like a wrapper, to change its behavior. They can thus act as a shorthand to change the behavior of functions. Say for example, it was common that we wanted to run functions multiple times. Rather than changing the function, making it more complicated, we could add a decorator to change the behavior of a more simple function. In Python decorators use the \sphinxcode{\sphinxupquote{%
\PYG{o}{@}%
}} symbol. For example in Python we might write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@run\PYGZus{}multiple\PYGZus{}times}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{add\PYGZus{}and\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{%
\PYG{n+nd}{@run\PYGZus{}multiple\PYGZus{}times}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}%
}} is a decorator which will change the behavior of the following function. It takes an input argument, \sphinxcode{\sphinxupquote{%
\PYG{l+m+mi}{3}%
}} in this case. This can help give more readable code compared to changing the function itself, particularly if we have lots of different functions which all need the same behavior.

\sphinxAtStartPar
We won’t go into how to make our own decorators here. They are commonly encountered when performing {\hyperref[\detokenize{chapters/software_development_tools/automated_testing:unit-testing}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{unit testing}}}}} to define how the test works, and so it’s important to mention them briefly here. We’ll see how to use pre\sphinxhyphen{}defined decorators when we cover unit testing in the lab.


\subsection{Iterators and generators}
\label{\detokenize{chapters/programming_fundamentals/advanced_topics:iterators-and-generators}}
\sphinxAtStartPar
We mentioned iterators briefly when considering {\hyperref[\detokenize{chapters/programming_fundamentals/conditionals_and_loops:for-loops}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{for loops}}}}}. Lots of objects have an iterator method built in which tells the computer how many items are stored in the object, and which comes next in sequence. It can then loop through each one of these in turn, we don’t have to count ourselves how many items are in a list (say). Again, we didn’t go into how to make an iterator. You can do, but we’ll just use the built in ones.

\sphinxAtStartPar
In Python it’s common to hear about \sphinxstyleemphasis{generators} as well. A generator is like an iterator, but just generates a sequence to use later, rather than actually iterating through all of the items. You can use a generator to get a list of a sequence, and put it in a variable to be used later.

\sphinxAtStartPar
For example, maybe you have code such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}generator} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i} \PYG{o}{*} \PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} this is the generator, it will evaluate to 0, 1, 4, 9, 16}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{squares\PYGZus{}generator}\PYG{p}{:}
   \PYG{c+c1}{\PYGZsh{} put for loop code in here}
\end{sphinxVerbatim}

\sphinxAtStartPar
This lets us separate out where we make the list of items, and where we actually iterate through them. Importantly, a generator is only actually evaluated when it’s used, not when it’s defined. It’s thus almost like we’re putting the code into \sphinxcode{\sphinxupquote{%
\PYG{n}{my\PYGZus{}generator}%
}} rather than the list of items. This is very useful when you have a very large list you want to define at a particular point in the code, but not necessarily keep in memory until later.

\sphinxAtStartPar
We won’t particularly use generators in this course, but they’re common in Python and so important to know that they exist so that you can read about them if you need to.

\sphinxstepscope


\chapter{Wider factors to consider}
\label{\detokenize{chapters/wider_factors:wider-factors-to-consider}}\label{\detokenize{chapters/wider_factors::doc}}
\sphinxAtStartPar
As with most beginning programming courses, most of this course will focus on writing code to achieve a specific function. Getting code that has the correct functionality, without bugs or other issues, is the core goal. There’s plenty to learn just doing this!

\sphinxAtStartPar
Of course, for high quality code there are lots of other factors that need to be taken into account, beyond only \sphinxstyleemphasis{does the code implement the correct function}. We discuss some of these briefly here.


\section{Security and risk}
\label{\detokenize{chapters/wider_factors:security-and-risk}}
\sphinxAtStartPar
Cyber security and the hacking of computer systems are major concerns for many organizations which handle sensitive data. Which is basically every organization, no one wants their private data to be stolen.

\sphinxAtStartPar
In the UK, there are laws which govern how some information has to be kept securely. If data is stolen, it has to be reported to the \sphinxhref{https://ico.org.uk/}{Information Commissioner’s Office}, and potentially there can be fines and other sanctions if suitable procedures are not followed. Organizations routinely rate cyber attacks as one of the highest impact, and most probable, risks that they face and have to take actions to mitigate against.

\sphinxAtStartPar
Poor programming can give many attack vectors for hackers and other malicious actors to exploit. For the small projects we consider in this course, attacks on the code likely won’t be a major concern, but they may be a substantial design constraint in bigger real\sphinxhyphen{}world projects.

\sphinxAtStartPar
When discussing {\hyperref[\detokenize{chapters/software_development_tools/libraries:code-security}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{using code from the Internet}}}}} we already highlighted that you should take care when downloading and running external code. A key {\hyperref[\detokenize{chapters/motivation/our_choices:motivation}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{motivation}}}}} for our focus on Rust, with a smaller portion of C/C++, is to set you on a path to producing code with fewer memory safety issues which could lead to security vulnerabilities.


\section{Sustainability}
\label{\detokenize{chapters/wider_factors:sustainability}}
\sphinxAtStartPar
Environmental and financial sustainability is very important. All of our computers use power, and if our programs are inefficient, they will use more power and more resources than they need to. In the scheme of things, each individual computer only consumes a small amount of power. This adds up though!

\sphinxAtStartPar
It is estimated that about \sphinxhref{https://doi-org.manchester.idm.oclc.org/10.1145/3613207}{10\% of the world’s electricity is used on Information and Communications Technologies}. Each query on ChatGPT is (roughly) equivalent to \sphinxhref{https://medium.com/@zodhyatech/how-much-energy-does-chatgpt-consume-4cba1a7aef85}{keeping a light on for 5 minutes}. Data centres also use a lot of water for cooling. In addition to the environmental impact, electricity costs money, as does cooling to manage the temperature of computers.

\sphinxAtStartPar
There’s then the electronic waste impact. Code which can run using only very few resources will likely be able to run on older harder, keeping it in service for longer and reducing how much we have to throw away. In programming there’s often more than one way to achieve the same function. We’ll touch briefly on computational complexity, but for big projects you might need to dig deeper and look at how to optimize the run time, or other resource requirements, of your code with an eye on the sustainability impact.

\sphinxAtStartPar
In 2015, UN member states agreed to 17 global Sustainable Development Goals (SDGs) to end poverty, protect the planet, and ensure prosperity for all. Being a fundamental technology with many applications, there are likely examples of computer programs which contribute towards all 17 goals.

\sphinxAtStartPar
For example, code to analyze medical data and produce a summary report might contribute to \sphinxstyleemphasis{Goal 3: Good health and wellbeing}. Code monitoring the amount of renewable energy being generated, and changing how this is passed to the grid, might contribute to \sphinxstyleemphasis{Goal 7: Affordable and clean energy}. Code modelling water flows and leakages in water pipes might contribute to \sphinxstyleemphasis{Goal 6: Clean water and sanitation.} There are many more possible examples.


\section{Equality, Diversity, Inclusion and Accessibility}
\label{\detokenize{chapters/wider_factors:equality-diversity-inclusion-and-accessibility}}
\sphinxAtStartPar
Essentially, everybody uses and needs access to computers and the results of computer code. Equality, diversity, inclusion and accessibility are thus important to consider, and there are many places where they interact with the code that we write. We’ll briefly list a few examples below, but there are many more.

\sphinxAtStartPar
Our code is fundamentally written in English. Commands such as \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{print}%
}} to display something to the screen, assume familiarity with written English. We’ve discussed {\hyperref[\detokenize{chapters/programming_fundamentals/text_encoding:text-encoding}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{text encoding}}}}} previously. While modern code and programs will nearly all support UTF\sphinxhyphen{}8 and having non\sphinxhyphen{}English characters, for example with accents and similar, it’s not super\sphinxhyphen{}uncommon to still run into programs that struggle with non\sphinxhyphen{}ASCII characters.

\sphinxAtStartPar
In our programs, needing to store a person’s name is fairly common. Here’s an example list of \sphinxhref{https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/}{falsehoods programmers believe about names}. Without care and thought, and inclusive co\sphinxhyphen{}design, it’s easy to accidentally make code that some people can’t put their name into.

\sphinxAtStartPar
We’re going to use Git a lot for our version control. We noted that Git can have \sphinxstyleemphasis{branches}, allowing multiple copies of the same code to be developed in parallel. Today the default branch is called \sphinxstyleemphasis{main}. Historically it was called \sphinxstyleemphasis{master}. The implication being that there were slave branches.

\sphinxAtStartPar
We’ve tried to make these notes as inclusive and as accessible as possible. They have a dark mode, and a mode using a Dyslexia accessible font. Many of the tools we’re going to use, such as VSCode, are very customizable. They can be set up to use colors, contrasts, and fonts that the user prefers. It is generally up to the user to change the default settings though.

\sphinxAtStartPar
In general, we would advise you to read these notes once, at the start of the course. There’s quite a few notes and so it will take a good few hours, but it will time well spent. There will likely be lots of items that you don’t completely follow or don’t make sense. Don’t dwell on them for too long. Press on and read through everything before starting the labs. This will give you the best starting point. Then, come back to this section at the end of the course and read through it again. After you’ve done all of the labs, lots of things which you didn’t completely follow at first will likely make much more sense.

\sphinxAtStartPar
Links to the other parts of the course:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://uom-eee-eeen1xxx2.github.io/}{Part 0 on course administration}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://uom-eee-eeen1xxx2.github.io/notes-part1/}{Part 1 (this part) on underlying theory of how computers operate}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://uom-eee-eeen1xxx2.github.io/notes-part2/}{Part 2 on general purpose computing, mainly with Python}.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://uom-eee-eeen1xxx2.github.io/notes-part3/}{Part 3 on higher performance computing, mainly with Rust}.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}